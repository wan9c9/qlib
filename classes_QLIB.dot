digraph "classes_QLIB" {
rankdir=BT
charset="utf-8"
"qlib.workflow.record_temp.ACRecordTemp" [color="black", fontcolor="black", label="{ACRecordTemp|skip_existing : bool\l|generate()\l}", shape="record", style="solid"];
"qlib.contrib.strategy.rule_strategy.ACStrategy" [color="black", fontcolor="black", label="{ACStrategy|eta : float\lfreq : str\linstruments : str\llamb : float\lsignal : dict\ltrade_amount : dict\lwindow_size : int\l|generate_trade_decision(execute_result)\lreset(outer_trade_decision: BaseTradeDecision)\lreset_level_infra(level_infra)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_adarnn.ADARNN" [color="black", fontcolor="black", label="{ADARNN|batch_size : int\ld_feat : int\ldevice\ldropout : float\ldw : float\learly_stop : int\lfitted : bool\lhidden_size : int\llen_seq : int\llen_win : int\llogger\lloss : str\lloss_type : str\llr : float\lmetric : str\lmodel\ln_epochs : int\ln_splits : int\lnum_layers : int\loptimizer : str\lpre_epoch : int\lseed : NoneType\ltrain_optimizer : SGD, Adam\luse_gpu\l|calc_all_metrics(pred)\lfit(dataset: DatasetH, evals_result, save_path)\linfer(x_test)\llog_metrics(mode, metrics)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\ltest_epoch(df)\ltrain_AdaRNN(train_loader_list, epoch, dist_old, weight_mat)\ltransform_type(init_weight)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_add.ADD" [color="black", fontcolor="black", label="{ADD|ADD_model\lbase_model : str\lbatch_size : int\ld_feat : int\ldec_dropout : float\ldevice\ldropout : float\learly_stop : int\lfitted : bool\lgamma : float\lgamma_clip : float\lhi\lhidden_size : int\llo\llogger\llr : float\lmetric : str\lmodel_path : NoneType\lmu : float\ln_epochs : int\lnum_layers : int\loptimizer : str\lseed : NoneType\ltrain_optimizer : Adam, SGD\luse_gpu\l|bootstrap_fit(x_train, y_train, m_train, x_valid, y_valid, m_valid)\lcal_ic_metrics(pred, label)\lfit(dataset: DatasetH, evals_result, save_path)\lfit_thresh(train_label)\lgen_market_label(df, raw_label)\lget_daily_inter(df, shuffle)\llog_metrics(mode, metrics)\lloss_adv(adv_excess, label_excess, adv_market, label_market, record)\lloss_adv_excess(adv_excess, label_excess, record)\lloss_adv_market(adv_market, label_market, record)\lloss_fn(x, preds, label_excess, label_market, record)\lloss_pre(pred_excess, label_excess, pred_market, label_market, record)\lloss_pre_excess(pred_excess, label_excess, record)\lloss_pre_market(pred_market, label_market, record)\lloss_rec(x, rec_x, record)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\ltest_epoch(data_x, data_y, data_m)\ltrain_epoch(x_train_values, y_train_values, m_train_values)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_add.ADDModel" [color="black", fontcolor="black", label="{ADDModel|adv_excess\ladv_market\lbase_model : str\lbefore_adv_excess\lbefore_adv_market\ld_feat : int\ldec\lenc_excess\lenc_market\lpred_excess\lpred_market\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_alstm_ts.ALSTM" [color="black", fontcolor="black", label="{ALSTM|ALSTM_model\lbatch_size : int\ld_feat : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\lhidden_size : int\llogger\lloss : str\llr : float\lmetric : str\ln_epochs : int\ln_jobs : int\lnum_layers : int\loptimizer : str\lseed : NoneType\ltrain_optimizer : SGD, Adam\luse_gpu\l|fit(dataset, evals_result, save_path, reweighter)\lloss_fn(pred, label, weight)\lmetric_fn(pred, label)\lmse(pred, label, weight)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\ltest_epoch(data_loader)\ltrain_epoch(data_loader)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_alstm.ALSTM" [color="black", fontcolor="black", label="{ALSTM|ALSTM_model\lbatch_size : int\ld_feat : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\lhidden_size : int\llogger\lloss : str\llr : float\lmetric : str\ln_epochs : int\lnum_layers : int\loptimizer : str\lseed : NoneType\ltrain_optimizer : SGD, Adam\luse_gpu\l|fit(dataset: DatasetH, evals_result, save_path)\lloss_fn(pred, label)\lmetric_fn(pred, label)\lmse(pred, label)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\ltest_epoch(data_x, data_y)\ltrain_epoch(x_train, y_train)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_alstm_ts.ALSTMModel" [color="black", fontcolor="black", label="{ALSTMModel|att_net : Sequential\ldropout : float\lfc_out : Linear\lhid_size : int\linput_size : int\lnet : Sequential\lrnn\lrnn_layer : int\lrnn_type : str\l|forward(inputs)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_alstm.ALSTMModel" [color="black", fontcolor="black", label="{ALSTMModel|att_net : Sequential\ldropout : float\lfc_out : Linear\lhid_size : int\linput_size : int\lnet : Sequential\lrnn\lrnn_layer : int\lrnn_type : str\l|forward(inputs)\l}", shape="record", style="solid"];
"qlib.data.ops.Abs" [color="black", fontcolor="black", label="{Abs|\l|}", shape="record", style="solid"];
"qlib.backtest.account.Account" [color="black", fontcolor="black", label="{Account|accum_info\lbenchmark_config : NoneType\lcurrent_position\lfreq : NoneType\lhist_positions : dict\lindicator\linit_cash\lportfolio_metrics : NoneType\l|get_cash()\lget_hist_positions()\lget_portfolio_metrics()\lget_trade_indicator(): Indicator\linit_vars(init_cash, position_dict, freq: str, benchmark_config: dict)\lis_port_metr_enabled()\lreset(freq, benchmark_config, port_metr_enabled: bool)\lreset_report(freq, benchmark_config)\lupdate_bar_end(trade_start_time, trade_end_time, trade_exchange: Exchange, atomic: bool, outer_trade_decision: BaseTradeDecision, trade_info: list, inner_order_indicators: List[Dict[str, pd.Series]], decision_list: List[Tuple[BaseTradeDecision, pd.Timestamp, pd.Timestamp]], indicator_config: dict)\lupdate_current_position(trade_start_time, trade_end_time, trade_exchange)\lupdate_hist_positions(trade_start_time)\lupdate_indicator(trade_start_time, trade_exchange: Exchange, atomic: bool, outer_trade_decision: BaseTradeDecision, trade_info: list, inner_order_indicators: List[Dict[str, pd.Series]], decision_list: List[Tuple[BaseTradeDecision, pd.Timestamp, pd.Timestamp]], indicator_config: dict)\lupdate_order(order, trade_val, cost, trade_price)\lupdate_portfolio_metrics(trade_start_time, trade_end_time)\l}", shape="record", style="solid"];
"qlib.backtest.account.AccumulatedInfo" [color="black", fontcolor="black", label="{AccumulatedInfo|cost : int\lget_cost\lget_return\lget_turnover\lrtn : int\lto : int\l|add_cost(value)\ladd_return_value(value)\ladd_turnover(value)\lreset()\l}", shape="record", style="solid"];
"qlib.rl.interpreter.ActionInterpreter" [color="black", fontcolor="black", label="{ActionInterpreter|\l|interpret(action)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_adarnn.AdaRNN" [color="black", fontcolor="black", label="{AdaRNN|bn_lst : ModuleList\lbottleneck : Sequential\lfc : Linear\lfc_out : Linear\lfeatures : Sequential\lgate : ModuleList\lhiddens : list\llen_seq : int\lmodel_type : str\ln_input : int\ln_output : int\lnum_layers\lsoftmax : Softmax\ltrans_loss : str\luse_bottleneck : bool\l|forward_Boosting(x, weight_mat)\lforward_pre_train(x, len_win)\lget_features(output_list)\lgru_features(x, predict)\linit_layers()\lpredict(x)\lprocess_gate_weight(out, index)\lupdate_weight_Boosting(weight_mat, dist_old, dist_new)\l}", shape="record", style="solid"];
"qlib.data.ops.Add" [color="black", fontcolor="black", label="{Add|\l|}", shape="record", style="solid"];
"qlib.contrib.data.handler.Alpha158" [color="black", fontcolor="black", label="{Alpha158|\l|get_feature_config()\lget_label_config()\lparse_config_to_fields(config)\l}", shape="record", style="solid"];
"qlib.contrib.data.handler.Alpha158vwap" [color="black", fontcolor="black", label="{Alpha158vwap|\l|get_label_config()\l}", shape="record", style="solid"];
"qlib.contrib.data.handler.Alpha360" [color="black", fontcolor="black", label="{Alpha360|\l|get_feature_config()\lget_label_config()\l}", shape="record", style="solid"];
"qlib.contrib.data.handler.Alpha360vwap" [color="black", fontcolor="black", label="{Alpha360vwap|\l|get_label_config()\l}", shape="record", style="solid"];
"qlib.data.ops.And" [color="black", fontcolor="black", label="{And|\l|}", shape="record", style="solid"];
"qlib.contrib.data.data.ArcticFeatureProvider" [color="black", fontcolor="black", label="{ArcticFeatureProvider|market_transaction_time_list : list\lretry_time : int\luri : str\l|feature(instrument, field, start_index, end_index, freq)\l}", shape="record", style="solid"];
"qlib.utils.paral.AsyncCaller" [color="black", fontcolor="black", label="{AsyncCaller|STOP_MARK : str\l|async_dec(ac_attr)\lclose()\lrun()\lwait(close)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tabnet.AttentionTransformer" [color="black", fontcolor="black", label="{AttentionTransformer|bn\lfc : Linear\lr\l|forward(a, priors)\l}", shape="record", style="solid"];
"qlib.model.ens.ensemble.AverageEnsemble" [color="black", fontcolor="black", label="{AverageEnsemble|\l|}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_sfm.AverageMeter" [color="black", fontcolor="black", label="{AverageMeter|avg : int\lcount : int\lsum : int\lval : int\l|reset()\lupdate(val, n)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_nn.AverageMeter" [color="black", fontcolor="black", label="{AverageMeter|avg : int\lcount : int\lsum : int\lval : int\l|reset()\lupdate(val, n)\l}", shape="record", style="solid"];
"qlib.contrib.report.graph.BarGraph" [color="black", fontcolor="black", label="{BarGraph|\l|}", shape="record", style="solid"];
"qlib.data.filter.BaseDFilter" [color="black", fontcolor="black", label="{BaseDFilter|\l|from_config(config)\lto_config()\l}", shape="record", style="solid"];
"qlib.backtest.executor.BaseExecutor" [color="black", fontcolor="black", label="{BaseExecutor|common_infra\ldeal_day : NoneType\ldealt_order_amount : defaultdict\lgenerate_portfolio_metrics : bool\lindicator_config : dict\llevel_infra\ltime_per_step : str\ltrack_data : bool\ltrade_account\ltrade_calendar\ltrade_exchange\lverbose : bool\l|collect_data(trade_decision: BaseTradeDecision, return_value: dict, level: int): List[object]\lexecute(trade_decision: BaseTradeDecision, level: int)\lfinished()\lget_all_executors()\lget_level_infra()\lreset(common_infra: CommonInfrastructure)\lreset_common_infra(common_infra, copy_trade_account)\l}", shape="record", style="solid"];
"qlib.contrib.report.graph.BaseGraph" [color="black", fontcolor="black", label="{BaseGraph|data : NoneType\lfigure\l|get_instance_with_graph_parameters(graph_type)\lshow_graph_in_notebook(figure_list)\l}", shape="record", style="solid"];
"qlib.data.dataset.storage.BaseHandlerStorage" [color="black", fontcolor="black", label="{BaseHandlerStorage|\l|fetch(selector: Union[pd.Timestamp, slice, str, list], level: Union[str, int], col_set: Union[str, List[str]], fetch_orig: bool, proc_func: Callable): \lfrom_df(df)\lis_proc_func_supported()\l}", shape="record", style="solid"];
"qlib.backtest.utils.BaseInfrastructure" [color="black", fontcolor="black", label="{BaseInfrastructure|\l|get(infra_name)\lget_support_infra()\lhas(infra_name)\lreset_infra()\lupdate(other)\l}", shape="record", style="solid"];
"qlib.rl.interpreter.BaseInterpreter" [color="black", fontcolor="black", label="{BaseInterpreter|\l|interpret()\l}", shape="record", style="solid"];
"qlib.model.base.BaseModel" [color="black", fontcolor="black", label="{BaseModel|\l|predict(): object\l}", shape="record", style="solid"];
"qlib.contrib.strategy.optimizer.base.BaseOptimizer" [color="black", fontcolor="black", label="{BaseOptimizer|\l|}", shape="record", style="solid"];
"qlib.backtest.high_performance_ds.BaseOrderIndicator" [color="black", fontcolor="black", label="{BaseOrderIndicator|data\llogger\l|assign(col: str, metric: Union[dict, pd.Series])\lget_index_data(metric): SingleData\lget_metric_series(metric: str): \lsum_all_indicators(order_indicator: list, indicators: Union[str, List[str]], metrics: float, fill_value)\lto_series(): Dict[Text, pd.Series]\ltransfer(func: Callable, new_col: str): Union[None, BaseSingleMetric]\l}", shape="record", style="solid"];
"qlib.backtest.position.BasePosition" [color="black", fontcolor="black", label="{BasePosition|ST_CASH : str\lST_NO : NoneType\l|add_count_all(bar)\lcalculate_stock_value(): float\lcheck_stock(stock_id: str): bool\lget_cash(include_settle: bool): float\lget_stock_amount(code): float\lget_stock_amount_dict(): Dict\lget_stock_list(): List\lget_stock_price(code): float\lget_stock_weight_dict(only_stock: bool): Dict\lsettle_commit()\lsettle_start(settle_type: str)\lskip_update(): bool\lupdate_order(order: Order, trade_val: float, cost: float, trade_price: float)\lupdate_stock_price(stock_id, price: float)\lupdate_weight_all()\l}", shape="record", style="solid"];
"qlib.data.data.BaseProvider" [color="black", fontcolor="black", label="{BaseProvider|\l|calendar(start_time, end_time, freq, future)\lfeatures(instruments, fields, start_time, end_time, freq, disk_cache, inst_processors)\linstruments(market, filter_pipe, start_time, end_time)\llist_instruments(instruments, start_time, end_time, freq, as_list)\l}", shape="record", style="solid"];
"qlib.data.cache.BaseProviderCache" [color="black", fontcolor="black", label="{BaseProviderCache|logger\lprovider\l|check_cache_exists(cache_path: Iterable, suffix_list): bool\lclear_cache(cache_path)\lget_cache_dir(dir_name: str, freq): Path\l}", shape="record", style="solid"];
"qlib.backtest.high_performance_ds.BaseQuote" [color="black", fontcolor="black", label="{BaseQuote|logger\l|get_all_stock(): Iterable\lget_data(stock_id: str, start_time: Union[pd.Timestamp, str], end_time: Union[pd.Timestamp, str], field: Union[str], method: Union[str, None]): Union[None, int, float, bool, IndexData]\l}", shape="record", style="solid"];
"qlib.rl.env.BaseRLEnv" [color="black", fontcolor="black", label="{BaseRLEnv|\l|reset()\lstep(action)\l}", shape="record", style="solid"];
"qlib.contrib.strategy.signal_strategy.BaseSignalStrategy" [color="black", fontcolor="black", label="{BaseSignalStrategy|risk_degree : float\lsignal : Optional[Signal]\l|get_risk_degree(trade_step)\l}", shape="record", style="solid"];
"qlib.backtest.high_performance_ds.BaseSingleMetric" [color="black", fontcolor="black", label="{BaseSingleMetric|empty\l|abs(): \ladd(other, fill_value: float): \lapply(func: dict): \lcount(): int\lmean(): float\lreplace(replace_dict: dict): \lsum(): float\l}", shape="record", style="solid"];
"qlib.data.storage.storage.BaseStorage" [color="black", fontcolor="black", label="{BaseStorage|storage_name\l|}", shape="record", style="solid"];
"qlib.strategy.base.BaseStrategy" [color="black", fontcolor="black", label="{BaseStrategy|common_infra\llevel_infra\louter_trade_decision : NoneType\ltrade_calendar\ltrade_exchange\ltrade_position\l|alter_outer_trade_decision(outer_trade_decision: BaseTradeDecision)\lgenerate_trade_decision(execute_result)\lget_data_cal_avail_range(rtype: str): Tuple[int, int]\lreset(level_infra: LevelInfrastructure, common_infra: CommonInfrastructure, outer_trade_decision)\lreset_common_infra(common_infra: CommonInfrastructure)\lreset_level_infra(level_infra: LevelInfrastructure)\lupdate_trade_decision(trade_decision: BaseTradeDecision, trade_calendar: TradeCalendarManager): Union[BaseTradeDecision, None]\l}", shape="record", style="solid"];
"qlib.backtest.decision.BaseTradeDecision" [color="black", fontcolor="black", label="{BaseTradeDecision|end_time\lstart_time\lstrategy\ltotal_step : NoneType\ltrade_range : Optional[TradeRange]\l|empty(): bool\lget_data_cal_range_limit(rtype: str, raise_error: bool): Tuple[int, int]\lget_decision(): List[object]\lget_range_limit(): Tuple[int, int]\lmod_inner_decision(inner_trade_decision: BaseTradeDecision)\lupdate(trade_calendar: TradeCalendarManager): Union['BaseTradeDecision', None]\l}", shape="record", style="solid"];
"qlib.utils.index_data.BinaryOps" [color="black", fontcolor="black", label="{BinaryOps|method_name\lobj\l|}", shape="record", style="solid"];
"qlib.data.dataset.processor.CSRankNorm" [color="black", fontcolor="black", label="{CSRankNorm|fields_group : NoneType\l|}", shape="record", style="solid"];
"qlib.data.dataset.processor.CSZFillna" [color="black", fontcolor="black", label="{CSZFillna|fields_group : NoneType\l|}", shape="record", style="solid"];
"qlib.data.dataset.processor.CSZScoreNorm" [color="black", fontcolor="black", label="{CSZScoreNorm|fields_group : NoneType, list\lzscore_func\l|}", shape="record", style="solid"];
"qlib.data.cache.CacheUtils" [color="black", fontcolor="black", label="{CacheUtils|LOCK_ID : str\l|acquire(lock, lock_name)\lorganize_meta_file()\lreader_lock(redis_t: str, lock_name)\lreset_lock()\lvisit(cache_path)\lwriter_lock(redis_t, lock_name)\l}", shape="record", style="solid"];
"qlib.data.cache.CalendarCache" [color="black", fontcolor="black", label="{CalendarCache|\l|}", shape="record", style="solid"];
"qlib.data.data.CalendarProvider" [color="black", fontcolor="black", label="{CalendarProvider|\l|calendar(start_time, end_time, freq, future)\lload_calendar(freq, future)\llocate_index(start_time, end_time, freq, future)\l}", shape="record", style="solid"];
"qlib.data.storage.storage.CalendarStorage" [color="black", fontcolor="black", label="{CalendarStorage|data\lfreq : str\lfuture : bool\lkwargs : dict\l|clear(): \lextend(iterable: Iterable[CalVT]): \lindex(value: CalVT): int\linsert(index: int, value: CalVT): \lremove(value: CalVT): \l}", shape="record", style="solid"];
"qlib.contrib.model.catboost_model.CatBoostModel" [color="black", fontcolor="black", label="{CatBoostModel|model : NoneType, CatBoost\l|fit(dataset: DatasetH, num_boost_round, early_stopping_rounds, verbose_eval, evals_result, reweighter)\lget_feature_importance(): \lpredict(dataset: DatasetH, segment: Union[Text, slice])\l}", shape="record", style="solid"];
"qlib.contrib.model.tcn.Chomp1d" [color="black", fontcolor="black", label="{Chomp1d|chomp_size\l|forward(x)\l}", shape="record", style="solid"];
"qlib.data.client.Client" [color="black", fontcolor="black", label="{Client|logger\lserver_host\lserver_port\lsio : Client\l|connect_server()\ldisconnect()\lsend_request(request_type, request_content, msg_queue, msg_proc_func)\l}", shape="record", style="solid"];
"qlib.data.data.ClientCalendarProvider" [color="black", fontcolor="black", label="{ClientCalendarProvider|conn : NoneType\lqueue : Queue\l|calendar(start_time, end_time, freq, future)\lset_conn(conn)\l}", shape="record", style="solid"];
"qlib.data.data.ClientDatasetProvider" [color="black", fontcolor="black", label="{ClientDatasetProvider|conn : NoneType\lqueue : Queue\l|dataset(instruments, fields, start_time, end_time, freq, disk_cache, return_uri, inst_processors)\lset_conn(conn)\l}", shape="record", style="solid"];
"qlib.data.data.ClientInstrumentProvider" [color="black", fontcolor="black", label="{ClientInstrumentProvider|conn : NoneType\lqueue : Queue\l|list_instruments(instruments, start_time, end_time, freq, as_list)\lset_conn(conn)\l}", shape="record", style="solid"];
"qlib.data.data.ClientProvider" [color="black", fontcolor="black", label="{ClientProvider|client\llogger\l|}", shape="record", style="solid"];
"qlib.workflow.task.collect.Collector" [color="black", fontcolor="black", label="{Collector|pickle_backend : str\lprocess_list : list\l|collect(): dict\lprocess_collect(collected_dict, process_list): dict\l}", shape="record", style="solid"];
"qlib.contrib.report.data.ana.CombFeaAna" [color="black", fontcolor="black", label="{CombFeaAna|\l|calc_stat_values()\lplot_all()\lskip(col)\l}", shape="record", style="solid"];
"qlib.backtest.utils.CommonInfrastructure" [color="black", fontcolor="black", label="{CommonInfrastructure|\l|get_support_infra()\l}", shape="record", style="solid"];
"qlib.model.utils.ConcatDataset" [color="black", fontcolor="black", label="{ConcatDataset|datasets : tuple\l|}", shape="record", style="solid"];
"qlib.config.Config" [color="black", fontcolor="black", label="{Config|\l|get(key, default)\lreset()\lset_conf_from_C(config_c)\lupdate()\l}", shape="record", style="solid"];
"qlib.contrib.data.processor.ConfigSectionProcessor" [color="black", fontcolor="black", label="{ConfigSectionProcessor|clip_feature_outlier\lclip_label_outlier\lfields_group : NoneType\lfillna_feature\lfillna_label\lshrink_feature_outlier\l|}", shape="record", style="solid"];
"qlib.data.ops.Corr" [color="black", fontcolor="black", label="{Corr|\l|}", shape="record", style="solid"];
"qlib.data.ops.Count" [color="black", fontcolor="black", label="{Count|\l|}", shape="record", style="solid"];
"qlib.data.ops.Cov" [color="black", fontcolor="black", label="{Cov|\l|}", shape="record", style="solid"];
"qlib.contrib.model.double_ensemble.DEnsembleModel" [color="black", fontcolor="black", label="{DEnsembleModel|alpha1 : float\lalpha2 : float\lbase_model : str\lbins_fs : int\lbins_sr : int\ldecay : NoneType\lenable_fs : bool\lenable_sr : bool\lensemble : list\lepochs : int\llogger\lloss : str\lnum_models : int\lparams : dict\lsample_ratios : NoneType, list\lsub_features : list\lsub_weights : list, NoneType\l|feature_selection(df_train, loss_values)\lfit(dataset: DatasetH)\lget_feature_importance(): \lget_loss(label, pred)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\lpredict_sub(submodel, df_data, features)\lretrieve_loss_curve(model, df_train, features)\lsample_reweight(loss_curve, loss_values, k_th)\ltrain_submodel(df_train, df_valid, weights, features)\l}", shape="record", style="solid"];
"qlib.data.dataset.loader.DLWParser" [color="black", fontcolor="black", label="{DLWParser|fields : tuple\lis_group : bool\l|load(instruments, start_time, end_time): \lload_group_df(instruments, exprs: list, names: list, start_time: Union[str, pd.Timestamp], end_time: Union[str, pd.Timestamp], gp_name: str): \l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_nn.DNNModelPytorch" [color="black", fontcolor="black", label="{DNNModelPytorch|batch_size : int\lbest_step : NoneType\ldata_parall : bool\ldevice\ldnn_model : NoneType, dict\learly_stop_rounds : int\leval_steps : int\leval_train_metric : bool\lfitted : bool\llogger\lloss_type : str\llr : float\llr_decay : float\llr_decay_steps : int\lmax_steps : int\loptimizer : str\lscheduler : NoneType, ReduceLROnPlateau\lseed : NoneType\ltrain_optimizer : Adam, SGD\luse_gpu\lvalid_key : str\lweight_decay : float\l|fit(dataset: DatasetH, evals_result, verbose, save_path, reweighter)\lget_loss(pred, w, target, loss_type)\lget_lr()\lget_metric(pred, target, index)\lload(buffer)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\lsave(filename)\l}", shape="record", style="solid"];
"qlib.workflow.online.update.DSBasedUpdater" [color="black", fontcolor="black", label="{DSBasedUpdater|fname : str\lfreq : str\lhist_ref : Optional[int]\llast_end\lold_data : DataFrame\lrmdl\lto_date : NoneType\l|get_update_data(dataset: Dataset): \lprepare_data(unprepared_dataset: Optional[DatasetH]): DatasetH\lupdate(dataset: DatasetH, write: bool, ret_new: bool): Optional[object]\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_gats_ts.DailyBatchSampler" [color="black", fontcolor="black", label="{DailyBatchSampler|daily_count\ldaily_index : ndarray\ldata_source\l|}", shape="record", style="solid"];
"qlib.data.dataset.handler.DataHandler" [color="black", fontcolor="black", label="{DataHandler|CS_ALL : str\lCS_RAW : str\ldata_loader : NoneType\lend_time : NoneType\lfetch_orig : bool\linstruments : NoneType\lstart_time : NoneType\l|config()\lfetch(selector: Union[pd.Timestamp, slice, str, pd.Index], level: Union[str, int], col_set: Union[str, List[str]], squeeze: bool, proc_func: Callable): \lget_cols(col_set): list\lget_range_iterator(periods: int, min_periods: Optional[int]): Iterator[Tuple[pd.Timestamp, pd.DataFrame]]\lget_range_selector(cur_date: Union[pd.Timestamp, str], periods: int): slice\lsetup_data(enable_cache: bool)\l}", shape="record", style="solid"];
"qlib.data.dataset.handler.DataHandlerLP" [color="black", fontcolor="black", label="{DataHandlerLP|ATTR_MAP : dict\lDK_I : str\lDK_L : str\lDK_R : str\lIT_FIT_IND : str\lIT_FIT_SEQ : str\lIT_LS : str\lPTYPE_A : str\lPTYPE_I : str\ldrop_raw : bool\lfrom_cast : bool\linfer_processors : list\llearn_processors : list\lprocess_type : str\lshared_processors : list\l|cast(cls, handler): \lconfig(processor_kwargs: dict)\lfetch(selector: Union[pd.Timestamp, slice, str], level: Union[str, int], col_set, data_key: str, squeeze: bool, proc_func: Callable): \lfit()\lfit_process_data()\lget_all_processors()\lget_cols(col_set, data_key: str): list\lprocess_data(with_fit: bool)\lsetup_data(init_type: str)\l}", shape="record", style="solid"];
"qlib.data.dataset.loader.DataLoader" [color="black", fontcolor="black", label="{DataLoader|\l|load(instruments, start_time, end_time): \l}", shape="record", style="solid"];
"qlib.data.dataset.loader.DataLoaderDH" [color="black", fontcolor="black", label="{DataLoaderDH|fetch_kwargs : dict\lhandlers\lis_group : bool\l|load(instruments, start_time, end_time): \l}", shape="record", style="solid"];
"qlib.config.QlibConfig.DataPathManager" [color="black", fontcolor="black", label="{DataPathManager|mount_path : Union[str, Path, dict]\lprovider_uri : Union[str, Path, dict]\l|format_provider_uri(provider_uri): dict\lget_data_uri(freq: Optional[Union[str, Freq]]): Path\lget_uri_type(uri)\l}", shape="record", style="solid"];
"qlib.data.dataset.Dataset" [color="black", fontcolor="black", label="{Dataset|\l|config()\lprepare(): object\lsetup_data()\l}", shape="record", style="solid"];
"qlib.data.cache.DatasetCache" [color="black", fontcolor="black", label="{DatasetCache|HDF_KEY : str\l|cache_to_origin_data(data, fields)\ldataset(instruments, fields, start_time, end_time, freq, disk_cache, inst_processors)\lnormalize_uri_args(instruments, fields, freq)\lupdate(cache_uri: Union[str, Path], freq: str)\l}", shape="record", style="solid"];
"qlib.data.dataset.DatasetH" [color="black", fontcolor="black", label="{DatasetH|fetch_kwargs : dict\lhandler\lsegments\l|config(handler_kwargs: dict)\lget_max_time(segments)\lget_min_time(segments)\lprepare(segments: Union[List[Text], Tuple[Text], Text, slice, pd.Index], col_set, data_key): Union[List[pd.DataFrame], pd.DataFrame]\lsetup_data(handler_kwargs: dict)\l}", shape="record", style="solid"];
"qlib.data.data.DatasetProvider" [color="black", fontcolor="black", label="{DatasetProvider|\l|dataset(instruments, fields, start_time, end_time, freq, inst_processors)\ldataset_processor(instruments_d, column_names, start_time, end_time, freq, inst_processors)\lget_column_names(fields)\lget_instruments_d(instruments, freq)\linst_calculator(inst, start_time, end_time, freq, column_names, spans, g_config, inst_processors)\lparse_fields(fields)\l}", shape="record", style="solid"];
"qlib.data.cache.DatasetURICache" [color="black", fontcolor="black", label="{DatasetURICache|\l|dataset(instruments, fields, start_time, end_time, freq, disk_cache, inst_processors)\l}", shape="record", style="solid"];
"qlib.utils.compare_dict_value.DateEncoder" [color="black", fontcolor="black", label="{DateEncoder|\l|default(o)\l}", shape="record", style="solid"];
"qlib.contrib.ops.high_freq.DayCumsum" [color="black", fontcolor="black", label="{DayCumsum|end : datetime\lend_id\lfeature\lmorning_close : datetime\lmorning_open : datetime\lnoon_close : datetime\lnoon_open : datetime\lstart : datetime\lstart_id\l|period_cusum(df)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tabnet.DecisionStep" [color="black", fontcolor="black", label="{DecisionStep|atten_tran\lfea_tran\l|forward(x, a, priors)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_add.Decoder" [color="black", fontcolor="black", label="{Decoder|base_model : str\lfc : Linear\lrnn : LSTM, GRU\l|forward(x, hidden)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tabnet.DecoderStep" [color="black", fontcolor="black", label="{DecoderStep|fc : Linear\lfea_tran\l|forward(x)\l}", shape="record", style="solid"];
"qlib.model.trainer.DelayTrainerR" [color="black", fontcolor="black", label="{DelayTrainerR|delay : bool\lend_train_func\l|end_train(models, end_train_func, experiment_name: str): List[Recorder]\l}", shape="record", style="solid"];
"qlib.model.trainer.DelayTrainerRM" [color="black", fontcolor="black", label="{DelayTrainerRM|delay : bool\lend_train_func\lskip_run_task : bool\l|end_train(recs, end_train_func, experiment_name: str): List[Recorder]\lhas_worker(): bool\ltrain(tasks: list, train_func, experiment_name: str): List[Recorder]\lworker(end_train_func, experiment_name: str)\l}", shape="record", style="solid"];
"qlib.utils.paral.DelayedDict" [color="black", fontcolor="black", label="{DelayedDict|delayed_tpl\lkey_l\l|get_delayed_tuple()\lget_replacement()\l}", shape="record", style="solid"];
"qlib.utils.paral.DelayedTask" [color="black", fontcolor="black", label="{DelayedTask|res\l|get_delayed_tuple()\lget_replacement()\lset_res(res)\l}", shape="record", style="solid"];
"qlib.utils.paral.DelayedTuple" [color="black", fontcolor="black", label="{DelayedTuple|delayed_tpl\lres : NoneType\l|get_delayed_tuple()\lget_replacement()\l}", shape="record", style="solid"];
"qlib.data.ops.Delta" [color="black", fontcolor="black", label="{Delta|\l|}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_adarnn.Discriminator" [color="black", fontcolor="black", label="{Discriminator|dis1 : Linear\ldis2 : Linear\lhidden_dim : int\linput_dim : int\l|forward(x)\l}", shape="record", style="solid"];
"qlib.data.cache.DiskDatasetCache" [color="black", fontcolor="black", label="{DiskDatasetCache|r : Redis\lremote\l|gen_dataset_cache(cache_path: Union[str, Path], instruments, fields, freq, inst_processors)\lget_cache_dir(freq: str): Path\lread_data_from_cache(cls: Union[str, Path], cache_path, start_time, end_time, fields)\lupdate(cache_uri, freq: str)\l}", shape="record", style="solid"];
"qlib.data.cache.DiskExpressionCache" [color="black", fontcolor="black", label="{DiskExpressionCache|r : Redis\lremote\l|gen_expression_cache(expression_data, cache_path, instrument, field, freq, last_update)\lget_cache_dir(freq: str): Path\lupdate(sid, cache_uri, freq: str)\l}", shape="record", style="solid"];
"qlib.contrib.report.graph.DistplotGraph" [color="black", fontcolor="black", label="{DistplotGraph|\l|}", shape="record", style="solid"];
"qlib.data.ops.Div" [color="black", fontcolor="black", label="{Div|\l|}", shape="record", style="solid"];
"qlib.data.dataset.processor.DropCol" [color="black", fontcolor="black", label="{DropCol|col_list : list\l|readonly()\l}", shape="record", style="solid"];
"qlib.data.dataset.processor.DropnaLabel" [color="black", fontcolor="black", label="{DropnaLabel|\l|is_for_infer(): bool\l}", shape="record", style="solid"];
"qlib.data.dataset.processor.DropnaProcessor" [color="black", fontcolor="black", label="{DropnaProcessor|fields_group : NoneType\l|readonly()\l}", shape="record", style="solid"];
"qlib.data.ops.EMA" [color="black", fontcolor="black", label="{EMA|\l|}", shape="record", style="solid"];
"qlib.data.ops.ElemOperator" [color="black", fontcolor="black", label="{ElemOperator|feature\l|get_extended_window_size()\lget_longest_back_rolling()\l}", shape="record", style="solid"];
"qlib.backtest.decision.EmptyTradeDecision" [color="black", fontcolor="black", label="{EmptyTradeDecision|\l|empty(): bool\l}", shape="record", style="solid"];
"qlib.contrib.strategy.optimizer.enhanced_indexing.EnhancedIndexingOptimizer" [color="black", fontcolor="black", label="{EnhancedIndexingOptimizer|b_dev : Optional[float]\ldelta : Optional[float]\lepsilon : float\lf_dev : Optional[Union[List[float], np.ndarray]]\llamb : float\lscale_return : bool\lsolver_kwargs : Optional[Dict[str, Any]]\l|}", shape="record", style="solid"];
"qlib.contrib.strategy.signal_strategy.EnhancedIndexingStrategy" [color="black", fontcolor="black", label="{EnhancedIndexingStrategy|BLACKLIST_NAME : str\lFACTOR_COV_NAME : str\lFACTOR_EXP_NAME : str\lSPECIFIC_RISK_NAME : str\lblacklist_path\lfactor_cov_path\lfactor_exp_path\llogger\lmarket : str\loptimizer\lriskmodel_root\lspecific_risk_path\lturn_limit : NoneType\lverbose : bool\l|generate_target_weight_position(score, current, trade_start_time, trade_end_time)\lget_risk_data(date)\l}", shape="record", style="solid"];
"qlib.model.ens.ensemble.Ensemble" [color="black", fontcolor="black", label="{Ensemble|\l|}", shape="record", style="solid"];
"qlib.data.ops.Eq" [color="black", fontcolor="black", label="{Eq|\l|}", shape="record", style="solid"];
"qlib.backtest.exchange.Exchange" [color="black", fontcolor="black", label="{Exchange|LT_FLT : str\lLT_NONE : str\lLT_TP_EXP : str\lall_fields : list\lbuy_price : NoneType\lbuy_vol_limit : NoneType, list\lclose_cost : float\lcodes : str\lend_time : NoneType\lextra_quote : NoneType\lfreq : str\limpact_cost : float\llimit_threshold : Optional[Union[Tuple[str, str], float, None]]\llimit_type : str\llogger\lmin_cost : int\lopen_cost : float\lquote\lquote_cls\lquote_df : NoneType\lsell_price : NoneType\lsell_vol_limit : NoneType, list\lstart_time : NoneType\ltrade_unit\ltrade_w_adj_price : bool\lvolume_threshold : NoneType\l|calculate_amount_position_value(amount_dict, start_time, end_time, only_tradable, direction)\lcheck_order(order)\lcheck_stock_limit(stock_id, start_time, end_time, direction)\lcheck_stock_suspended(stock_id, start_time, end_time)\ldeal_order(order, trade_account: Account, position: BasePosition, dealt_order_amount: defaultdict)\lgenerate_amount_position_from_weight_position(weight_position, cash, start_time, end_time, direction)\lgenerate_order_for_target_amount_position(target_position, current_position, start_time, end_time)\lget_amount_of_trade_unit(factor: float, stock_id: str, start_time, end_time)\lget_close(stock_id, start_time, end_time, method)\lget_deal_price(stock_id, start_time, end_time, direction: OrderDir, method)\lget_factor(stock_id, start_time, end_time): Union[float, None]\lget_order_helper(): OrderHelper\lget_quote_from_qlib()\lget_quote_info(stock_id, start_time, end_time, method)\lget_real_deal_amount(current_amount, target_amount, factor)\lget_volume(stock_id, start_time, end_time, method)\lis_stock_tradable(stock_id, start_time, end_time, direction)\lround_amount_by_trade_unit(deal_amount, factor: float, stock_id: str, start_time, end_time)\l}", shape="record", style="solid"];
"qlib.utils.exceptions.ExpAlreadyExistError" [color="black", fontcolor="red", label="{ExpAlreadyExistError|\l|}", shape="record", style="solid"];
"qlib.workflow.expm.ExpManager" [color="black", fontcolor="black", label="{ExpManager|active_experiment : NoneType\ldefault_uri\luri\l|create_exp(experiment_name: Optional[Text])\ldelete_exp(experiment_id, experiment_name)\lend_exp(recorder_status: Text)\lget_exp()\llist_experiments()\lsearch_records(experiment_ids)\lset_uri(uri: Optional[Text])\lstart_exp()\l}", shape="record", style="solid"];
"qlib.workflow.exp.Experiment" [color="black", fontcolor="black", label="{Experiment|RT_D : str\lRT_L : str\lactive_recorder : NoneType\lid\linfo\lname\l|create_recorder(recorder_name)\ldelete_recorder(recorder_id)\lend(recorder_status)\lget_recorder(recorder_id, recorder_name, create: bool, start: bool)\llist_recorders(rtype: str): Union[List[Recorder], Dict[str, Recorder]]\lsearch_records()\lstart()\l}", shape="record", style="solid"];
"qlib.data.base.Expression" [color="black", fontcolor="black", label="{Expression|\l|get_extended_window_size()\lget_longest_back_rolling()\lload(instrument, start_index, end_index, freq)\l}", shape="record", style="solid"];
"qlib.data.cache.ExpressionCache" [color="black", fontcolor="black", label="{ExpressionCache|\l|expression(instrument, field, start_time, end_time, freq)\lupdate(cache_uri: Union[str, Path], freq: str)\l}", shape="record", style="solid"];
"qlib.data.filter.ExpressionDFilter" [color="black", fontcolor="black", label="{ExpressionDFilter|rule_expression\l|from_config(config)\lto_config()\l}", shape="record", style="solid"];
"qlib.data.base.ExpressionOps" [color="black", fontcolor="black", label="{ExpressionOps|\l|}", shape="record", style="solid"];
"qlib.data.data.ExpressionProvider" [color="black", fontcolor="black", label="{ExpressionProvider|expression_instance_cache : dict\l|expression(instrument, field, start_time, end_time, freq): \lget_expression_instance(field)\l}", shape="record", style="solid"];
"qlib.contrib.report.data.ana.FeaACAna" [color="black", fontcolor="black", label="{FeaACAna|ylim : tuple\l|calc_stat_values()\lplot_single(col, ax)\l}", shape="record", style="solid"];
"qlib.contrib.report.data.base.FeaAnalyser" [color="black", fontcolor="black", label="{FeaAnalyser|\l|calc_stat_values()\lplot_all()\lplot_single(col, ax)\lskip(col)\l}", shape="record", style="solid"];
"qlib.contrib.report.data.ana.FeaDistAna" [color="black", fontcolor="black", label="{FeaDistAna|\l|plot_single(col, ax)\l}", shape="record", style="solid"];
"qlib.contrib.report.data.ana.FeaInfAna" [color="black", fontcolor="black", label="{FeaInfAna|\l|calc_stat_values()\lplot_single(col, ax)\lskip(col)\l}", shape="record", style="solid"];
"qlib.contrib.report.data.ana.FeaMeanStd" [color="black", fontcolor="black", label="{FeaMeanStd|\l|calc_stat_values()\lplot_single(col, ax)\l}", shape="record", style="solid"];
"qlib.contrib.report.data.ana.FeaNanAna" [color="black", fontcolor="black", label="{FeaNanAna|\l|calc_stat_values()\lplot_single(col, ax)\lskip(col)\l}", shape="record", style="solid"];
"qlib.contrib.report.data.ana.FeaNanAnaRatio" [color="black", fontcolor="black", label="{FeaNanAnaRatio|\l|calc_stat_values()\lplot_single(col, ax)\lskip(col)\l}", shape="record", style="solid"];
"qlib.contrib.report.data.ana.FeaSkewTurt" [color="black", fontcolor="black", label="{FeaSkewTurt|\l|calc_stat_values()\lplot_single(col, ax)\l}", shape="record", style="solid"];
"qlib.data.base.Feature" [color="black", fontcolor="black", label="{Feature|\l|get_extended_window_size()\lget_longest_back_rolling()\l}", shape="record", style="solid"];
"qlib.model.interpret.base.FeatureInt" [color="black", fontcolor="black", label="{FeatureInt|\l|get_feature_importance(): \l}", shape="record", style="solid"];
"qlib.data.data.FeatureProvider" [color="black", fontcolor="black", label="{FeatureProvider|\l|feature(instrument, field, start_time, end_time, freq)\l}", shape="record", style="solid"];
"qlib.data.storage.storage.FeatureStorage" [color="black", fontcolor="black", label="{FeatureStorage|data\lend_index\lfield : str\lfreq : str\linstrument : str\lkwargs : dict\lstart_index\l|clear(): \lrebase(start_index: int, end_index: int)\lrewrite(data: Union[List, np.ndarray, Tuple], index: int)\lwrite(data_array: Union[List, np.ndarray, Tuple], index: int)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tabnet.FeatureTransformer" [color="black", fontcolor="black", label="{FeatureTransformer|independ : ModuleList\lscale : float\lshared : ModuleList, NoneType\l|forward(x)\l}", shape="record", style="solid"];
"qlib.data.storage.file_storage.FileCalendarStorage" [color="black", fontcolor="black", label="{FileCalendarStorage|data\lenable_read_cache : bool\lfile_name\lfuture : bool\luri\l|clear(): \lextend(values: Iterable[CalVT]): \lindex(value: CalVT): int\linsert(index: int, value: CalVT)\lremove(value: CalVT): \l}", shape="record", style="solid"];
"qlib.data.storage.file_storage.FileFeatureStorage" [color="black", fontcolor="black", label="{FileFeatureStorage|data\lend_index\lfile_name\lstart_index\l|clear()\lwrite(data_array: Union[List, np.ndarray], index: int): \l}", shape="record", style="solid"];
"qlib.data.storage.file_storage.FileInstrumentStorage" [color="black", fontcolor="black", label="{FileInstrumentStorage|INSTRUMENT_END_FIELD : str\lINSTRUMENT_SEP : str\lINSTRUMENT_START_FIELD : str\lSYMBOL_FIELD_NAME : str\ldata\lfile_name\l|clear(): \lupdate(): \l}", shape="record", style="solid"];
"qlib.utils.objm.FileManager" [color="black", fontcolor="black", label="{FileManager|path : Path\l|create_path(): str\lexists(name)\llist()\lload_obj(name)\lremove(fname)\lsave_obj(obj, name)\lsave_objs(obj_name_l)\l}", shape="record", style="solid"];
"qlib.contrib.strategy.rule_strategy.FileOrderStrategy" [color="black", fontcolor="black", label="{FileOrderStrategy|order_df : TextFileReader\ltrade_range : Optional[Union[Tuple[int, int], TradeRange]]\l|generate_trade_decision(execute_result): TradeDecisionWO\l}", shape="record", style="solid"];
"qlib.data.storage.file_storage.FileStorageMixin" [color="black", fontcolor="black", label="{FileStorageMixin|dpm\lprovider_uri\lsupport_freq\luri\l|check()\l}", shape="record", style="solid"];
"qlib.data.dataset.processor.Fillna" [color="black", fontcolor="black", label="{Fillna|fields_group : NoneType\lfill_value : int\l|}", shape="record", style="solid"];
"qlib.data.dataset.processor.FilterCol" [color="black", fontcolor="black", label="{FilterCol|col_list : tuple, list\lfields_group : str\l|readonly()\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tabnet.FinetuneModel" [color="black", fontcolor="black", label="{FinetuneModel|fc : Linear\lmodel\l|forward(x, priors)\l}", shape="record", style="solid"];
"qlib.utils.time.Freq" [color="black", fontcolor="black", label="{Freq|MIN_CAL : list\lNORM_FREQ_DAY : str\lNORM_FREQ_MINUTE : str\lNORM_FREQ_MONTH : str\lNORM_FREQ_WEEK : str\lSUPPORT_CAL_LIST : list\lbase\lcount : int\l|get_min_delta(left_frq: str, right_freq)\lget_recent_freq(base_freq: List[Union[str, 'Freq']], freq_list): Optional['Freq']\lget_timedelta(n: str, freq): \lparse(freq): Tuple[int, str]\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_gats.GATModel" [color="black", fontcolor="black", label="{GATModel|a : Parameter\la_t\ld_feat : int\lfc : Linear\lfc_out : Linear\lhidden_size : int\lleaky_relu : LeakyReLU\lrnn : LSTM, GRU\lsoftmax : Softmax\ltransformation : Linear\l|cal_attention(x, y)\lforward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_gats_ts.GATModel" [color="black", fontcolor="black", label="{GATModel|a : Parameter\la_t\ld_feat : int\lfc : Linear\lfc_out : Linear\lhidden_size : int\lleaky_relu : LeakyReLU\lrnn : LSTM, GRU\lsoftmax : Softmax\ltransformation : Linear\l|cal_attention(x, y)\lforward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_gats.GATs" [color="black", fontcolor="black", label="{GATs|GAT_model\lbase_model : str\ld_feat : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\lhidden_size : int\llogger\lloss : str\llr : float\lmetric : str\lmodel_path : NoneType\ln_epochs : int\lnum_layers : int\loptimizer : str\lseed : NoneType\ltrain_optimizer : SGD, Adam\luse_gpu\l|fit(dataset: DatasetH, evals_result, save_path)\lget_daily_inter(df, shuffle)\lloss_fn(pred, label)\lmetric_fn(pred, label)\lmse(pred, label)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\ltest_epoch(data_x, data_y)\ltrain_epoch(x_train, y_train)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_gats_ts.GATs" [color="black", fontcolor="black", label="{GATs|GAT_model\lbase_model : str\ld_feat : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\lhidden_size : int\llogger\lloss : str\llr : float\lmetric : str\lmodel_path : NoneType\ln_epochs : int\ln_jobs : int\lnum_layers : int\loptimizer : str\lseed : NoneType\ltrain_optimizer : Adam, SGD\luse_gpu\l|fit(dataset, evals_result, save_path)\lget_daily_inter(df, shuffle)\lloss_fn(pred, label)\lmetric_fn(pred, label)\lmse(pred, label)\lpredict(dataset)\ltest_epoch(data_loader)\ltrain_epoch(data_loader)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tabnet.GBN" [color="black", fontcolor="black", label="{GBN|bn : BatchNorm1d\lvbs : int\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tabnet.GLU" [color="black", fontcolor="black", label="{GLU|bn\lfc : Linear, NoneType\lod\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_gru_ts.GRU" [color="black", fontcolor="black", label="{GRU|GRU_model\lbatch_size : int\ld_feat : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\lhidden_size : int\llogger\lloss : str\llr : float\lmetric : str\ln_epochs : int\ln_jobs : int\lnum_layers : int\loptimizer : str\lseed : NoneType\ltrain_optimizer : SGD, Adam\luse_gpu\l|fit(dataset, evals_result, save_path, reweighter)\lloss_fn(pred, label, weight)\lmetric_fn(pred, label)\lmse(pred, label, weight)\lpredict(dataset)\ltest_epoch(data_loader)\ltrain_epoch(data_loader)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_gru.GRU" [color="black", fontcolor="black", label="{GRU|batch_size : int\ld_feat : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\lgru_model\lhidden_size : int\llogger\lloss : str\llr : float\lmetric : str\ln_epochs : int\lnum_layers : int\loptimizer : str\lseed : NoneType\ltrain_optimizer : SGD, Adam\luse_gpu\l|fit(dataset: DatasetH, evals_result, save_path)\lloss_fn(pred, label)\lmetric_fn(pred, label)\lmse(pred, label)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\ltest_epoch(data_x, data_y)\ltrain_epoch(x_train, y_train)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tcts.GRUModel" [color="black", fontcolor="black", label="{GRUModel|d_feat : int\lfc_out : Linear\lrnn : GRU\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_gru_ts.GRUModel" [color="black", fontcolor="black", label="{GRUModel|d_feat : int\lfc_out : Linear\lrnn : GRU\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_gru.GRUModel" [color="black", fontcolor="black", label="{GRUModel|d_feat : int\lfc_out : Linear\lrnn : GRU\l|forward(x)\l}", shape="record", style="solid"];
"qlib.data.ops.Ge" [color="black", fontcolor="black", label="{Ge|\l|}", shape="record", style="solid"];
"qlib.tests.data.GetData" [color="black", fontcolor="black", label="{GetData|DATASET_VERSION : str\lQLIB_DATA_NAME : str\lREMOTE_URL : str\ldelete_zip_file : bool\l|check_dataset(file_name: str, dataset_version: str)\lcsv_data_cn(target_dir)\lmerge_remote_url(file_name: str, dataset_version: str)\lnormalize_dataset_version(dataset_version: str)\lqlib_data(name, target_dir, version, interval, region, delete_old, exists_skip)\l}", shape="record", style="solid"];
"qlib.data.ops.Greater" [color="black", fontcolor="black", label="{Greater|\l|}", shape="record", style="solid"];
"qlib.model.ens.group.Group" [color="black", fontcolor="black", label="{Group|\l|group(): dict\lreduce(): dict\l}", shape="record", style="solid"];
"qlib.data.ops.Gt" [color="black", fontcolor="black", label="{Gt|\l|}", shape="record", style="solid"];
"qlib.contrib.model.highfreq_gdbt_model.HFLGBModel" [color="black", fontcolor="black", label="{HFLGBModel|model : Booster, NoneType\lparams : dict\l|finetune(dataset: DatasetH, num_boost_round, verbose_eval)\lfit(dataset: DatasetH, num_boost_round, early_stopping_rounds, verbose_eval, evals_result)\lhf_signal_test(dataset: DatasetH, threhold)\lpredict(dataset)\l}", shape="record", style="solid"];
"qlib.workflow.record_temp.HFSignalRecord" [color="black", fontcolor="black", label="{HFSignalRecord|artifact_path : str\ldepend_cls\l|generate()\llist()\l}", shape="record", style="solid"];
"qlib.data.dataset.processor.HashStockFormat" [color="black", fontcolor="black", label="{HashStockFormat|\l|}", shape="record", style="solid"];
"qlib.data.dataset.storage.HasingStockStorage" [color="black", fontcolor="black", label="{HasingStockStorage|columns\lhash_df : dict\lstock_level : str\l|fetch(selector: Union[pd.Timestamp, slice, str], level: Union[str, int], col_set: Union[str, List[str]], fetch_orig: bool): \lfrom_df(df)\lis_proc_func_supported()\l}", shape="record", style="solid"];
"qlib.contrib.report.graph.HeatmapGraph" [color="black", fontcolor="black", label="{HeatmapGraph|\l|}", shape="record", style="solid"];
"qlib.contrib.report.graph.HistogramGraph" [color="black", fontcolor="black", label="{HistogramGraph|\l|}", shape="record", style="solid"];
"qlib.contrib.meta.data_selection.utils.ICLoss" [color="black", fontcolor="black", label="{ICLoss|\l|forward(pred, y, idx, skip_size)\l}", shape="record", style="solid"];
"qlib.data.ops.IdxMax" [color="black", fontcolor="black", label="{IdxMax|\l|}", shape="record", style="solid"];
"qlib.data.ops.IdxMin" [color="black", fontcolor="black", label="{IdxMin|\l|}", shape="record", style="solid"];
"qlib.backtest.decision.IdxTradeRange" [color="black", fontcolor="black", label="{IdxTradeRange|\l|}", shape="record", style="solid"];
"qlib.data.ops.If" [color="black", fontcolor="black", label="{If|condition\lfeature_left\lfeature_right\l|get_extended_window_size()\lget_longest_back_rolling()\l}", shape="record", style="solid"];
"qlib.utils.index_data.Index" [color="black", fontcolor="black", label="{Index|idx_list : ndarray\lindex_map : dict\l|index(item): int\lis_sorted()\lsort(): Tuple['Index', np.ndarray]\ltolist()\l}", shape="record", style="solid"];
"qlib.utils.index_data.IndexData" [color="black", fontcolor="black", label="{IndexData|columns\ldata : ndarray\lempty\liloc\lindex\lindices : tuple, List[Index]\lloc\lloc_idx_cls\lndim\lvalues\l|abs()\lall()\lapply(func: Callable)\lcount()\lfillna(value, inplace: bool)\lisna()\lmean(axis, dtype, out)\lreplace(to_replace: Dict[np.number, np.number])\lsort_index(axis, inplace)\lsum(axis, dtype, out)\l}", shape="record", style="solid"];
"qlib.data.cache.DiskDatasetCache.IndexManager" [color="black", fontcolor="black", label="{IndexManager|KEY : str\lindex_path\llogger\l|append_index(data, to_disk)\lbuild_index_from_data(data, start_index)\lget_index(start_time, end_time)\lsync_from_disk()\lsync_to_disk()\lupdate(data, sync)\l}", shape="record", style="solid"];
"qlib.model.utils.IndexSampler" [color="black", fontcolor="black", label="{IndexSampler|sampler\l|}", shape="record", style="solid"];
"qlib.backtest.report.Indicator" [color="black", fontcolor="black", label="{Indicator|order_indicator\lorder_indicator_cls\lorder_indicator_his : OrderedDict\ltrade_indicator : Dict[str, float], OrderedDict\ltrade_indicator_his : OrderedDict\l|agg_order_indicators(inner_order_indicators: List[Dict[str, pd.Series]], decision_list: List[Tuple[BaseTradeDecision, pd.Timestamp, pd.Timestamp]], outer_trade_decision: BaseTradeDecision, trade_exchange: Exchange, indicator_config)\lcal_trade_indicators(trade_start_time, freq, indicator_config)\lgenerate_trade_indicators_dataframe()\lget_order_indicator(raw: bool)\lget_trade_indicator()\lrecord(trade_start_time)\lreset()\lupdate_order_indicators(trade_info: list)\l}", shape="record", style="solid"];
"qlib.backtest.position.InfPosition" [color="black", fontcolor="black", label="{InfPosition|\l|add_count_all(bar)\lcalculate_stock_value(): float\lcheck_stock(stock_id: str): bool\lget_cash(include_settle): float\lget_stock_amount(code): float\lget_stock_amount_dict(): Dict\lget_stock_list(): List\lget_stock_price(code): float\lget_stock_weight_dict(only_stock: bool): Dict\lsettle_commit()\lsettle_start(settle_type: str)\lskip_update(): bool\lupdate_order(order: Order, trade_val: float, cost: float, trade_price: float)\lupdate_stock_price(stock_id, price: float)\lupdate_weight_all()\l}", shape="record", style="solid"];
"qlib.data.inst_processor.InstProcessor" [color="black", fontcolor="black", label="{InstProcessor|\l|}", shape="record", style="solid"];
"qlib.data.data.InstrumentProvider" [color="black", fontcolor="black", label="{InstrumentProvider|CONF : str\lDICT : str\lLIST : str\l|get_inst_type(cls, inst)\linstruments(market: Union[List, None], filter_pipe)\llist_instruments(instruments, start_time, end_time, freq, as_list)\l}", shape="record", style="solid"];
"qlib.data.storage.storage.InstrumentStorage" [color="black", fontcolor="black", label="{InstrumentStorage|data\lfreq : str\lkwargs : dict\lmarket : str\l|clear(): \lupdate(): \l}", shape="record", style="solid"];
"qlib.contrib.meta.data_selection.dataset.InternalData" [color="black", fontcolor="black", label="{InternalData|data_ic_df : DataFrame\ldh\lexp_name : str\lstep : int\ltask_tpl : dict\l|setup(trainer, trainer_kwargs)\lupdate()\l}", shape="record", style="solid"];
"qlib.data.ops.Kurt" [color="black", fontcolor="black", label="{Kurt|\l|}", shape="record", style="solid"];
"qlib.contrib.model.gbdt.LGBModel" [color="black", fontcolor="black", label="{LGBModel|early_stopping_rounds : int\lmodel : NoneType, Booster\lnum_boost_round : int\lparams : dict\l|finetune(dataset: DatasetH, num_boost_round, verbose_eval, reweighter)\lfit(dataset: DatasetH, num_boost_round, early_stopping_rounds, verbose_eval, evals_result, reweighter)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_lstm_ts.LSTM" [color="black", fontcolor="black", label="{LSTM|LSTM_model : NoneType\lbatch_size : int\ld_feat : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\lhidden_size : int\llogger\lloss : str\llr : float\lmetric : str\ln_epochs : int\ln_jobs : int\lnum_layers : int\loptimizer : str\lseed : NoneType\ltrain_optimizer : Adam, SGD\luse_gpu\l|fit(dataset, evals_result, save_path, reweighter)\lloss_fn(pred, label, weight)\lmetric_fn(pred, label)\lmse(pred, label, weight)\lpredict(dataset)\ltest_epoch(data_loader)\ltrain_epoch(data_loader)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_lstm.LSTM" [color="black", fontcolor="black", label="{LSTM|batch_size : int\ld_feat : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\lhidden_size : int\llogger\lloss : str\llr : float\llstm_model\lmetric : str\ln_epochs : int\lnum_layers : int\loptimizer : str\lseed : NoneType\ltrain_optimizer : SGD, Adam\luse_gpu\l|fit(dataset: DatasetH, evals_result, save_path)\lloss_fn(pred, label)\lmetric_fn(pred, label)\lmse(pred, label)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\ltest_epoch(data_x, data_y)\ltrain_epoch(x_train, y_train)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_lstm_ts.LSTMModel" [color="black", fontcolor="black", label="{LSTMModel|d_feat : int\lfc_out : Linear\lrnn : LSTM\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_lstm.LSTMModel" [color="black", fontcolor="black", label="{LSTMModel|d_feat : int\lfc_out : Linear\lrnn : LSTM\l|forward(x)\l}", shape="record", style="solid"];
"qlib.workflow.online.update.LabelUpdater" [color="black", fontcolor="black", label="{LabelUpdater|\l|get_update_data(dataset: Dataset): \l}", shape="record", style="solid"];
"qlib.data.ops.Le" [color="black", fontcolor="black", label="{Le|\l|}", shape="record", style="solid"];
"qlib.data.ops.Less" [color="black", fontcolor="black", label="{Less|\l|}", shape="record", style="solid"];
"qlib.backtest.utils.LevelInfrastructure" [color="black", fontcolor="black", label="{LevelInfrastructure|\l|get_support_infra()\lreset_cal(freq, start_time, end_time)\lset_sub_level_infra(sub_level_infra: LevelInfrastructure)\l}", shape="record", style="solid"];
"qlib.model.interpret.base.LightGBMFInt" [color="black", fontcolor="black", label="{LightGBMFInt|model : NoneType\l|get_feature_importance(): \l}", shape="record", style="solid"];
"qlib.contrib.model.linear.LinearModel" [color="black", fontcolor="black", label="{LinearModel|LASSO : str\lNNLS : str\lOLS : str\lRIDGE : str\lalpha : float\lcoef_ : NoneType, ndarray\lestimator : str\lfit_intercept : bool\lintercept_ : float\l|fit(dataset: DatasetH, reweighter: Reweighter)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\l}", shape="record", style="solid"];
"qlib.utils.exceptions.LoadObjectError" [color="black", fontcolor="red", label="{LoadObjectError|\l|}", shape="record", style="solid"];
"qlib.utils.index_data.LocIndexer" [color="black", fontcolor="black", label="{LocIndexer|\l|proc_idx_l(indices: Tuple, data_shape): List[Index]\l}", shape="record", style="solid"];
"qlib.data.data.LocalCalendarProvider" [color="black", fontcolor="black", label="{LocalCalendarProvider|backend : dict\lremote : bool\l|load_calendar(freq, future)\l}", shape="record", style="solid"];
"qlib.data.data.LocalDatasetProvider" [color="black", fontcolor="black", label="{LocalDatasetProvider|align_time : bool\l|cache_walker(inst, start_time, end_time, freq, column_names)\ldataset(instruments, fields, start_time, end_time, freq, inst_processors)\lmulti_cache_walker(instruments, fields, start_time, end_time, freq)\l}", shape="record", style="solid"];
"qlib.data.data.LocalExpressionProvider" [color="black", fontcolor="black", label="{LocalExpressionProvider|time2idx : bool\l|expression(instrument, field, start_time, end_time, freq)\l}", shape="record", style="solid"];
"qlib.data.data.LocalFeatureProvider" [color="black", fontcolor="black", label="{LocalFeatureProvider|backend : dict\lremote : bool\l|feature(instrument, field, start_index, end_index, freq)\l}", shape="record", style="solid"];
"qlib.data.data.LocalInstrumentProvider" [color="black", fontcolor="black", label="{LocalInstrumentProvider|backend : dict\l|list_instruments(instruments, start_time, end_time, freq, as_list)\l}", shape="record", style="solid"];
"qlib.data.data.LocalProvider" [color="black", fontcolor="black", label="{LocalProvider|\l|features_uri(instruments, fields, start_time, end_time, freq, disk_cache)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_localformer_ts.LocalformerEncoder" [color="black", fontcolor="black", label="{LocalformerEncoder|conv : ModuleList\llayers : ModuleList\lnum_layers\l|forward(src, mask)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_localformer.LocalformerEncoder" [color="black", fontcolor="black", label="{LocalformerEncoder|conv : ModuleList\llayers : ModuleList\lnum_layers\l|forward(src, mask)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_localformer_ts.LocalformerModel" [color="black", fontcolor="black", label="{LocalformerModel|batch_size : int\ld_model : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\llogger\lloss : str\llr : float\lmetric : str\lmodel\ln_epochs : int\ln_jobs : int\loptimizer : str\lreg : float\lseed : NoneType\ltrain_optimizer : SGD, Adam\luse_gpu\l|fit(dataset: DatasetH, evals_result, save_path)\lloss_fn(pred, label)\lmetric_fn(pred, label)\lmse(pred, label)\lpredict(dataset)\ltest_epoch(data_loader)\ltrain_epoch(data_loader)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_localformer.LocalformerModel" [color="black", fontcolor="black", label="{LocalformerModel|batch_size : int\ld_model : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\llogger\lloss : str\llr : float\lmetric : str\lmodel\ln_epochs : int\ln_jobs : int\loptimizer : str\lreg : float\lseed : NoneType\ltrain_optimizer : Adam, SGD\luse_gpu\l|fit(dataset: DatasetH, evals_result, save_path)\lloss_fn(pred, label)\lmetric_fn(pred, label)\lmse(pred, label)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\ltest_epoch(data_x, data_y)\ltrain_epoch(x_train, y_train)\l}", shape="record", style="solid"];
"qlib.data.ops.Log" [color="black", fontcolor="black", label="{Log|\l|}", shape="record", style="solid"];
"qlib.log.LogFilter" [color="black", fontcolor="black", label="{LogFilter|param : NoneType\l|filter(record)\lmatch_msg(filter_str, msg)\l}", shape="record", style="solid"];
"qlib.data.ops.Lt" [color="black", fontcolor="black", label="{Lt|\l|}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tcts.MLPModel" [color="black", fontcolor="black", label="{MLPModel|mlp : Sequential\lsoftmax : Softmax\l|forward(x)\l}", shape="record", style="solid"];
"qlib.workflow.expm.MLflowExpManager" [color="black", fontcolor="black", label="{MLflowExpManager|active_experiment : NoneType\lclient\l|create_exp(experiment_name: Optional[Text])\ldelete_exp(experiment_id, experiment_name)\lend_exp(recorder_status: Text)\llist_experiments()\lsearch_records(experiment_ids)\lstart_exp()\l}", shape="record", style="solid"];
"qlib.workflow.exp.MLflowExperiment" [color="black", fontcolor="black", label="{MLflowExperiment|UNLIMITED : int\lactive_recorder : NoneType\l|create_recorder(recorder_name)\ldelete_recorder(recorder_id, recorder_name)\lend(recorder_status)\llist_recorders(rtype, max_results: int, status: Union[str, None], filter_string: str)\lsearch_records()\lstart()\l}", shape="record", style="solid"];
"qlib.workflow.recorder.MLflowRecorder" [color="black", fontcolor="black", label="{MLflowRecorder|artifact_uri\lasync_log : NoneType\lclient : MlflowClient\lend_time : NoneType\lid\lname\lstart_time : NoneType\lstatus : str\luri\l|delete_tags()\lend_run(status: str)\lget_artifact_uri()\lget_local_dir()\llist_artifacts(artifact_path)\llist_metrics()\llist_params()\llist_tags()\lload_object(name, unpickler)\llog_metrics(step)\llog_params()\lsave_objects(local_path, artifact_path)\lset_tags()\lstart_run()\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_adarnn.MMD_loss" [color="black", fontcolor="black", label="{MMD_loss|fix_sigma : NoneType\lkernel_mul : float\lkernel_num : int\lkernel_type : str\l|forward(source, target)\lguassian_kernel(source, target, kernel_mul, kernel_num, fix_sigma)\llinear_mmd(X, Y)\l}", shape="record", style="solid"];
"qlib.contrib.data.dataset.MTSDatasetH" [color="black", fontcolor="black", label="{MTSDatasetH|batch_size : int\ldrop_last : bool\lhorizon : int\linput_size : NoneType\lmemory_mode : str\ln_samples : NoneType\lnum_states : int\lparams : tuple\lseq_len : int\lshuffle : bool\l|assign_data(index, vals)\lclear_memory()\leval()\lrestore_daily_index(daily_index)\lrestore_index(index)\lsetup_data(handler_kwargs: dict)\ltrain()\l}", shape="record", style="solid"];
"qlib.data.ops.Mad" [color="black", fontcolor="black", label="{Mad|\l|}", shape="record", style="solid"];
"qlib.data.ops.Mask" [color="black", fontcolor="black", label="{Mask|instrument\l|}", shape="record", style="solid"];
"qlib.data.ops.Max" [color="black", fontcolor="black", label="{Max|\l|}", shape="record", style="solid"];
"qlib.data.ops.Mean" [color="black", fontcolor="black", label="{Mean|\l|}", shape="record", style="solid"];
"qlib.data.ops.Med" [color="black", fontcolor="black", label="{Med|\l|}", shape="record", style="solid"];
"qlib.data.cache.MemCache" [color="black", fontcolor="black", label="{MemCache|\l|clear()\l}", shape="record", style="solid"];
"qlib.data.cache.MemCacheExpire" [color="black", fontcolor="black", label="{MemCacheExpire|CACHE_EXPIRE\l|get_cache(mem_cache, key)\lset_cache(mem_cache, key, value)\l}", shape="record", style="solid"];
"qlib.data.cache.MemCacheLengthUnit" [color="black", fontcolor="black", label="{MemCacheLengthUnit|\l|}", shape="record", style="solid"];
"qlib.data.cache.MemCacheSizeofUnit" [color="black", fontcolor="black", label="{MemCacheSizeofUnit|\l|}", shape="record", style="solid"];
"qlib.data.cache.MemCacheUnit" [color="black", fontcolor="black", label="{MemCacheUnit|limited\lod : OrderedDict\lsize_limit\ltotal_size\l|clear()\lpop(key)\lpopitem(last)\lset_limit_size(limit)\l}", shape="record", style="solid"];
"qlib.data.cache.MemoryCalendarCache" [color="black", fontcolor="black", label="{MemoryCalendarCache|\l|calendar(start_time, end_time, freq, future)\l}", shape="record", style="solid"];
"qlib.workflow.task.collect.MergeCollector" [color="black", fontcolor="black", label="{MergeCollector|collector_dict : Dict[str, Collector]\lmerge_func : NoneType\l|collect(): dict\l}", shape="record", style="solid"];
"qlib.contrib.meta.data_selection.dataset.MetaDatasetDS" [color="black", fontcolor="black", label="{MetaDatasetDS|hist_step_n : int\linternal_data\lmeta_task_l : list\lstep\lta\ltask_list : list\ltask_tpl\ltrunc_days : NoneType\l|}", shape="record", style="solid"];
"qlib.model.meta.model.MetaGuideModel" [color="black", fontcolor="black", label="{MetaGuideModel|\l|fit()\linference()\l}", shape="record", style="solid"];
"qlib.log.MetaLogger" [color="black", fontcolor="black", label="{MetaLogger|\l|}", shape="record", style="solid"];
"qlib.model.meta.model.MetaModel" [color="black", fontcolor="black", label="{MetaModel|\l|fit()\linference(): object\l}", shape="record", style="solid"];
"qlib.contrib.meta.data_selection.model.MetaModelDS" [color="black", fontcolor="black", label="{MetaModelDS|clip_method : str\lclip_weight : float\lcriterion : str\lfitted : bool\lhist_step_n\llr : float\lmax_epoch : int\lstep\ltn\l|fit(meta_dataset: MetaDatasetDS)\linference(meta_dataset: MetaTaskDataset): List[dict]\lrun_epoch(phase, task_list, epoch, opt, loss_l, ignore_weight)\l}", shape="record", style="solid"];
"qlib.model.meta.task.MetaTask" [color="black", fontcolor="black", label="{MetaTask|PROC_MODE_FULL : str\lPROC_MODE_TEST : str\lPROC_MODE_TRANSFER : str\lmeta_info : object\lmode : str\ltask : dict\l|get_dataset(): Dataset\lget_meta_input(): object\l}", shape="record", style="solid"];
"qlib.contrib.meta.data_selection.dataset.MetaTaskDS" [color="black", fontcolor="black", label="{MetaTaskDS|fill_method : str\lprocessed_meta_input : dict\l|get_meta_input()\l}", shape="record", style="solid"];
"qlib.model.meta.dataset.MetaTaskDataset" [color="black", fontcolor="black", label="{MetaTaskDataset|segments : Union[Dict[Text, Tuple], float]\l|prepare_tasks(segments: Union[List[Text], Text]): List[MetaTask]\l}", shape="record", style="solid"];
"qlib.model.meta.model.MetaTaskModel" [color="black", fontcolor="black", label="{MetaTaskModel|\l|fit(meta_dataset: MetaTaskDataset)\linference(meta_dataset: MetaTaskDataset): List[dict]\l}", shape="record", style="solid"];
"qlib.data.ops.Min" [color="black", fontcolor="black", label="{Min|\l|}", shape="record", style="solid"];
"qlib.data.dataset.processor.MinMaxNorm" [color="black", fontcolor="black", label="{MinMaxNorm|cols\lfields_group : NoneType\lfit_end_time\lfit_start_time\lignore\lmax_val : ndarray\lmin_val : ndarray\l|fit(df)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_adarnn.Mine" [color="black", fontcolor="black", label="{Mine|fc1_x : Linear\lfc1_y : Linear\lfc2 : Linear\l|forward(x, y)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_adarnn.Mine_estimator" [color="black", fontcolor="black", label="{Mine_estimator|mine_model\l|forward(X, Y)\l}", shape="record", style="solid"];
"qlib.model.base.Model" [color="black", fontcolor="black", label="{Model|\l|fit(dataset: Dataset, reweighter: Reweighter)\lpredict(dataset: Dataset, segment: Union[Text, slice]): object\l}", shape="record", style="solid"];
"qlib.model.base.ModelFT" [color="black", fontcolor="black", label="{ModelFT|\l|finetune(dataset: Dataset)\l}", shape="record", style="solid"];
"qlib.backtest.signal.ModelSignal" [color="black", fontcolor="black", label="{ModelSignal|dataset : Dataset\lmodel\l|}", shape="record", style="solid"];
"qlib.data.ops.Mul" [color="black", fontcolor="black", label="{Mul|\l|}", shape="record", style="solid"];
"qlib.utils.index_data.MultiData" [color="black", fontcolor="black", label="{MultiData|\l|}", shape="record", style="solid"];
"qlib.workflow.task.gen.MultiHorizonGenBase" [color="black", fontcolor="black", label="{MultiHorizonGenBase|horizon : list\llabel_leak_n : int\lta\ltest_key : str\l|generate(task: dict)\lset_horizon(task: dict, hr: int)\l}", shape="record", style="solid"];
"qlib.contrib.workflow.record_temp.MultiSegRecord" [color="black", fontcolor="black", label="{MultiSegRecord|dataset\lmodel\l|generate(segments: Dict[Text, Any], save: bool)\l}", shape="record", style="solid"];
"qlib.data.filter.NameDFilter" [color="black", fontcolor="black", label="{NameDFilter|name_rule_re\l|from_config(config)\lto_config()\l}", shape="record", style="solid"];
"qlib.data.ops.Ne" [color="black", fontcolor="black", label="{Ne|\l|}", shape="record", style="solid"];
"qlib.backtest.executor.NestedExecutor" [color="black", fontcolor="black", label="{NestedExecutor|inner_executor\linner_strategy\l|get_all_executors()\lpost_inner_exe_step(inner_exe_res)\lreset_common_infra(common_infra, copy_trade_account)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_nn.Net" [color="black", fontcolor="black", label="{Net|dnn_layers : ModuleList\l|forward(x)\l}", shape="record", style="solid"];
"qlib.data.ops.Not" [color="black", fontcolor="black", label="{Not|\l|}", shape="record", style="solid"];
"qlib.data.ops.NpElemOperator" [color="black", fontcolor="black", label="{NpElemOperator|func\l|}", shape="record", style="solid"];
"qlib.data.ops.NpPairOperator" [color="black", fontcolor="black", label="{NpPairOperator|func\l|}", shape="record", style="solid"];
"qlib.contrib.report.data.ana.NumFeaAnalyser" [color="black", fontcolor="black", label="{NumFeaAnalyser|\l|skip(col)\l}", shape="record", style="solid"];
"qlib.backtest.high_performance_ds.NumpyOrderIndicator" [color="black", fontcolor="black", label="{NumpyOrderIndicator|data : Dict[str, SingleData]\l|assign(col: str, metric: dict)\lget_index_data(metric)\lget_metric_series(metric: str): Union[pd.Series]\lsum_all_indicators(order_indicator: list, indicators: Union[str, List[str]], metrics, fill_value)\lto_series(): Dict[str, pd.Series]\l}", shape="record", style="solid"];
"qlib.backtest.high_performance_ds.NumpyQuote" [color="black", fontcolor="black", label="{NumpyQuote|data : dict\lfreq\lregion : str\l|get_all_stock()\lget_data(stock_id, start_time, end_time, field, method)\l}", shape="record", style="solid"];
"qlib.utils.objm.ObjManager" [color="black", fontcolor="black", label="{ObjManager|\l|exists(name: str): bool\llist(): list\lload_obj(name: str): object\lremove(fname)\lsave_obj(obj: object, name: str)\lsave_objs(obj_name_l)\l}", shape="record", style="solid"];
"qlib.workflow.online.manager.OnlineManager" [color="black", fontcolor="black", label="{OnlineManager|SIM_LOG_LEVEL : int\lSIM_LOG_NAME : str\lSTATUS_ONLINE : str\lSTATUS_SIMULATING : str\lbegin_time\lcur_time\lfreq : str\lhistory : dict\llogger\lsignals : NoneType\lstatus : str\lstrategies : Union[OnlineStrategy, List[OnlineStrategy]]\ltrainer : Optional[Trainer]\l|add_strategy(strategies: Union[OnlineStrategy, List[OnlineStrategy]])\ldelay_prepare(model_kwargs, signal_kwargs)\lfirst_train(strategies: List[OnlineStrategy], model_kwargs: dict)\lget_collector(): MergeCollector\lget_signals(): Union[pd.Series, pd.DataFrame]\lprepare_signals(prepare_func: Callable, over_write)\lroutine(cur_time: Union[str, pd.Timestamp], task_kwargs: dict, model_kwargs: dict, signal_kwargs: dict)\lsimulate(end_time, frequency, task_kwargs, model_kwargs, signal_kwargs): Union[pd.Series, pd.DataFrame]\l}", shape="record", style="solid"];
"qlib.workflow.online.strategy.OnlineStrategy" [color="black", fontcolor="black", label="{OnlineStrategy|logger\lname_id : str\ltool\l|first_tasks(): List[dict]\lget_collector(): Collector\lprepare_online_models(trained_models, cur_time): List[object]\lprepare_tasks(cur_time): List[dict]\l}", shape="record", style="solid"];
"qlib.workflow.online.utils.OnlineTool" [color="black", fontcolor="black", label="{OnlineTool|OFFLINE_TAG : str\lONLINE_KEY : str\lONLINE_TAG : str\llogger\l|get_online_tag(recorder: object): str\lonline_models(): list\lreset_online_tag(recorder: Union[list, object])\lset_online_tag(tag, recorder: Union[list, object])\lupdate_online_pred(to_date)\l}", shape="record", style="solid"];
"qlib.workflow.online.utils.OnlineToolR" [color="black", fontcolor="black", label="{OnlineToolR|default_exp_name : Optional[str]\l|get_online_tag(recorder: Recorder): str\lonline_models(exp_name: str): list\lreset_online_tag(recorder: Union[Recorder, List], exp_name: str)\lset_online_tag(tag, recorder: Union[Recorder, List])\lupdate_online_pred(to_date, from_date, exp_name: str)\l}", shape="record", style="solid"];
"qlib.contrib.online.operator.Operator" [color="black", fontcolor="black", label="{Operator|client : str\llogger\l|add_user(id, config, path, date)\lexecute(date, exchange_config, path)\lgenerate(date, path)\linit(client, path, date)\lremove_user(id, path)\lshow(id, path, bench)\lsimulate(id, config, exchange_config, start, end, path, bench)\lupdate(date, path, type)\l}", shape="record", style="solid"];
"qlib.data.ops.OpsWrapper" [color="black", fontcolor="black", label="{OpsWrapper|\l|register(ops_list: List[Union[Type[ExpressionOps], dict]])\lreset()\l}", shape="record", style="solid"];
"qlib.contrib.tuner.config.OptimizationConfig" [color="black", fontcolor="black", label="{OptimizationConfig|optim_type\lreport_factor\lreport_type\l|}", shape="record", style="solid"];
"qlib.data.ops.Or" [color="black", fontcolor="black", label="{Or|\l|}", shape="record", style="solid"];
"qlib.backtest.decision.Order" [color="black", fontcolor="black", label="{Order|BUY : ClassVar[OrderDir]\lSELL : ClassVar[OrderDir]\lamount : float\lamount_delta\ldeal_amount : Optional[float]\ldeal_amount_delta\ldirection : int\lend_time\lfactor : Optional[float]\lsign\lstart_time\lstock_id : str\l|parse_dir(direction): Union[OrderDir, np.ndarray]\l}", shape="record", style="solid"];
"qlib.backtest.decision.OrderDir" [color="black", fontcolor="black", label="{OrderDir|name\l|}", shape="record", style="solid"];
"qlib.contrib.strategy.order_generator.OrderGenWInteract" [color="black", fontcolor="black", label="{OrderGenWInteract|\l|generate_order_list_from_target_weight_position(current: Position, trade_exchange: Exchange, target_weight_position: dict, risk_degree: float, pred_start_time, pred_end_time, trade_start_time, trade_end_time): list\l}", shape="record", style="solid"];
"qlib.contrib.strategy.order_generator.OrderGenWOInteract" [color="black", fontcolor="black", label="{OrderGenWOInteract|\l|generate_order_list_from_target_weight_position(current: Position, trade_exchange: Exchange, target_weight_position: dict, risk_degree: float, pred_start_time, pred_end_time, trade_start_time, trade_end_time): list\l}", shape="record", style="solid"];
"qlib.contrib.strategy.order_generator.OrderGenerator" [color="black", fontcolor="black", label="{OrderGenerator|\l|generate_order_list_from_target_weight_position(current: Position, trade_exchange: Exchange, target_weight_position: dict, risk_degree: float, pred_start_time, pred_end_time, trade_start_time, trade_end_time): list\l}", shape="record", style="solid"];
"qlib.backtest.decision.OrderHelper" [color="black", fontcolor="black", label="{OrderHelper|exchange\l|create(code: str, amount: float, direction: OrderDir, start_time: Union[str, pd.Timestamp], end_time: Union[str, pd.Timestamp]): Order\l}", shape="record", style="solid"];
"qlib.model.riskmodel.poet.POETCovEstimator" [color="black", fontcolor="black", label="{POETCovEstimator|THRESH_HARD : str\lTHRESH_SCAD : str\lTHRESH_SOFT : str\lnum_factors : int\lthresh : float\lthresh_method : str\l|}", shape="record", style="solid"];
"qlib.data.ops.PairOperator" [color="black", fontcolor="black", label="{PairOperator|feature_left\lfeature_right\l|get_extended_window_size()\lget_longest_back_rolling()\l}", shape="record", style="solid"];
"qlib.data.ops.PairRolling" [color="black", fontcolor="black", label="{PairRolling|N\lfeature_left\lfeature_right\lfunc\l|get_extended_window_size()\lget_longest_back_rolling()\l}", shape="record", style="solid"];
"qlib.backtest.high_performance_ds.PandasOrderIndicator" [color="black", fontcolor="black", label="{PandasOrderIndicator|data : Dict[str, PandasSingleMetric]\l|assign(col: str, metric: Union[dict, pd.Series])\lget_index_data(metric)\lget_metric_series(metric: str): Union[pd.Series]\lsum_all_indicators(order_indicator: list, indicators: Union[str, List[str]], metrics, fill_value)\lto_series()\l}", shape="record", style="solid"];
"qlib.backtest.high_performance_ds.PandasQuote" [color="black", fontcolor="black", label="{PandasQuote|data : dict\l|get_all_stock()\lget_data(stock_id, start_time, end_time, field, method)\l}", shape="record", style="solid"];
"qlib.backtest.high_performance_ds.PandasSingleMetric" [color="black", fontcolor="black", label="{PandasSingleMetric|empty\lindex\lmetric : Series, dict\l|abs()\ladd(other, fill_value)\lapply(func: Callable)\lcount()\lmean()\lreindex(index, fill_value)\lreplace(replace_dict: dict)\lsum()\l}", shape="record", style="solid"];
"qlib.utils.paral.ParallelExt" [color="black", fontcolor="black", label="{ParallelExt|\l|}", shape="record", style="solid"];
"qlib.contrib.tuner.pipeline.Pipeline" [color="black", fontcolor="black", label="{Pipeline|GLOBAL_BEST_PARAMS_NAME : str\lbacktest_config\lbest_tuner_index : NoneType\ldata_config\lglobal_best_params : NoneType\lglobal_best_res : NoneType\llogger\loptim_config\lpipeline_config\lpipeline_ex_config\lqlib_client_config\ltime_config\ltuner_config_manager\l|init_tuner(tuner_index, tuner_config)\lrun()\lsave_tuner_exp_info()\l}", shape="record", style="solid"];
"qlib.contrib.tuner.config.PipelineExperimentConfig" [color="black", fontcolor="black", label="{PipelineExperimentConfig|estimator_ex_dir\lglobal_dir\lname\ltuner_class\ltuner_ex_dir\ltuner_module_path\l|}", shape="record", style="solid"];
"qlib.workflow.record_temp.PortAnaRecord" [color="black", fontcolor="black", label="{PortAnaRecord|all_freq : list\lartifact_path : str\lbacktest_config\ldepend_cls\lexecutor_config\lindicator_analysis_freq\lindicator_analysis_method : NoneType\lrisk_analysis_freq\lstrategy_config\l|list()\l}", shape="record", style="solid"];
"qlib.backtest.report.PortfolioMetrics" [color="black", fontcolor="black", label="{PortfolioMetrics|accounts : OrderedDict\lbench : NoneType\lbenches : OrderedDict\lbenchmark_config : NoneType\lcashes : OrderedDict\lcosts : OrderedDict\lfreq : NoneType\llatest_pm_time : NoneType\lreturns : OrderedDict\ltotal_costs : OrderedDict\ltotal_turnovers : OrderedDict\lturnovers : OrderedDict\lvalues : OrderedDict\l|generate_portfolio_metrics_dataframe()\lget_latest_account_value()\lget_latest_date()\lget_latest_total_cost()\lget_latest_total_turnover()\linit_bench(freq, benchmark_config)\linit_vars()\lis_empty()\lload_portfolio_metrics(path)\lsave_portfolio_metrics(path)\lupdate_portfolio_metrics_record(trade_start_time, trade_end_time, account_value, cash, return_rate, total_turnover, turnover_rate, total_cost, cost_rate, stock_value, bench_value)\l}", shape="record", style="solid"];
"qlib.contrib.strategy.optimizer.optimizer.PortfolioOptimizer" [color="black", fontcolor="black", label="{PortfolioOptimizer|OPT_GMV : str\lOPT_INV : str\lOPT_MVO : str\lOPT_RP : str\lalpha : float\ldelta : float\llamb : float\lmethod : str\lscale_return : bool\ltol : float\l|}", shape="record", style="solid"];
"qlib.backtest.position.Position" [color="black", fontcolor="black", label="{Position|init_cash : float\lposition\l|add_count_all(bar)\lcalculate_stock_value()\lcalculate_value()\lcheck_stock(stock_id)\lfill_stock_value(start_time: Union[str, pd.Timestamp], freq: str, last_days: int)\lget_cash(include_settle)\lget_stock_amount(code)\lget_stock_amount_dict()\lget_stock_count(code, bar)\lget_stock_list()\lget_stock_price(code)\lget_stock_weight(code)\lget_stock_weight_dict(only_stock)\lsettle_commit()\lsettle_start(settle_type)\lupdate_order(order, trade_val, cost, trade_price)\lupdate_stock_count(stock_id, bar, count)\lupdate_stock_price(stock_id, price)\lupdate_stock_weight(stock_id, weight)\lupdate_weight_all()\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_localformer_ts.PositionalEncoding" [color="black", fontcolor="black", label="{PositionalEncoding|\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_transformer.PositionalEncoding" [color="black", fontcolor="black", label="{PositionalEncoding|\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_localformer.PositionalEncoding" [color="black", fontcolor="black", label="{PositionalEncoding|\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tra.PositionalEncoding" [color="black", fontcolor="black", label="{PositionalEncoding|dropout : Dropout\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_transformer_ts.PositionalEncoding" [color="black", fontcolor="black", label="{PositionalEncoding|\l|forward(x)\l}", shape="record", style="solid"];
"qlib.data.ops.Power" [color="black", fontcolor="black", label="{Power|exponent\l|}", shape="record", style="solid"];
"qlib.contrib.meta.data_selection.net.PredNet" [color="black", fontcolor="black", label="{PredNet|step\ltwm\l|forward(X, y, time_perf, time_belong, X_test, ignore_weight)\lget_sample_weights(X, time_perf, time_belong, ignore_weight)\linit_paramters(hist_step_n)\l}", shape="record", style="solid"];
"qlib.workflow.online.update.PredUpdater" [color="black", fontcolor="black", label="{PredUpdater|\l|get_update_data(dataset: Dataset): \l}", shape="record", style="solid"];
"qlib.data.dataset.processor.ProcessInf" [color="black", fontcolor="black", label="{ProcessInf|\l|}", shape="record", style="solid"];
"qlib.data.dataset.processor.Processor" [color="black", fontcolor="black", label="{Processor|\l|config()\lfit(df)\lis_for_infer(): bool\lreadonly(): bool\l}", shape="record", style="solid"];
"qlib.data.data.ProviderBackendMixin" [color="black", fontcolor="black", label="{ProviderBackendMixin|\l|backend_obj()\lget_default_backend()\l}", shape="record", style="solid"];
"qlib.contrib.tuner.tuner.QLibTuner" [color="black", fontcolor="black", label="{QLibTuner|ESTIMATOR_CONFIG_NAME : str\lEXP_INFO_NAME : str\lEXP_RESULT_DIR : str\lEXP_RESULT_NAME : str\lLOCAL_BEST_PARAMS_NAME : str\lbest_params\lbest_res : ndarray\l|fetch_result()\lobjective(params)\lsave_local_best_params()\lsetup_estimator_config(params)\lsetup_space()\l}", shape="record", style="solid"];
"qlib.data.cache.QlibCacheException" [color="black", fontcolor="red", label="{QlibCacheException|\l|}", shape="record", style="solid"];
"qlib.config.QlibConfig" [color="black", fontcolor="black", label="{QlibConfig|DEFAULT_FREQ : str\lLOCAL_URI : str\lNFS_URI : str\ldpm\lregistered\l|get_kernels(freq: str)\lis_depend_redis(cache_name)\lregister()\lreset_qlib_version()\lresolve_path()\lset(default_conf: str)\lset_mode(mode)\lset_region(region)\l}", shape="record", style="solid"];
"qlib.data.dataset.loader.QlibDataLoader" [color="black", fontcolor="black", label="{QlibDataLoader|filter_pipe : Optional[List]\lfreq : Union[str, dict]\linst_processor : NoneType, dict\lswap_level : bool\l|load_group_df(instruments, exprs: list, names: list, start_time: Union[str, pd.Timestamp], end_time: Union[str, pd.Timestamp], gp_name: str): \l}", shape="record", style="solid"];
"qlib.utils.exceptions.QlibException" [color="black", fontcolor="red", label="{QlibException|\l|}", shape="record", style="solid"];
"qlib.rl.env.QlibIntRLEnv" [color="black", fontcolor="black", label="{QlibIntRLEnv|action_interpreter\lstate_interpreter\l|step(action)\l}", shape="record", style="solid"];
"qlib.log.QlibLogger" [color="black", fontcolor="black", label="{QlibLogger|logger\lmodule_name\l|setLevel(level)\l}", shape="record", style="solid"];
"qlib.rl.env.QlibRLEnv" [color="black", fontcolor="black", label="{QlibRLEnv|executor\l|reset()\l}", shape="record", style="solid"];
"qlib.workflow.QlibRecorder" [color="black", fontcolor="black", label="{QlibRecorder|exp_manager\l|delete_exp(experiment_id, experiment_name)\ldelete_recorder(recorder_id, recorder_name)\lend_exp(recorder_status)\lget_exp(): Experiment\lget_recorder(): Recorder\lget_uri()\llist_experiments()\llist_recorders(experiment_id, experiment_name)\lload_object(name: Text)\llog_metrics(step)\llog_params()\lsave_objects(local_path, artifact_path)\lsearch_records(experiment_ids)\lset_tags()\lset_uri(uri: Optional[Text])\lstart()\lstart_exp()\luri_context(uri: Text)\l}", shape="record", style="solid"];
"qlib.data.ops.Quantile" [color="black", fontcolor="black", label="{Quantile|qscore\l|}", shape="record", style="solid"];
"qlib.strategy.base.RLIntStrategy" [color="black", fontcolor="black", label="{RLIntStrategy|action_interpreter\lpolicy\lstate_interpreter\l|generate_trade_decision(execute_result)\l}", shape="record", style="solid"];
"qlib.strategy.base.RLStrategy" [color="black", fontcolor="black", label="{RLStrategy|policy\l|}", shape="record", style="solid"];
"qlib.workflow.online.update.RMDLoader" [color="black", fontcolor="black", label="{RMDLoader|rec\l|get_dataset(start_time, end_time, segments, unprepared_dataset: Optional[DatasetH]): DatasetH\lget_model(): Model\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tra.RNN" [color="black", fontcolor="black", label="{RNN|W : Linear\lhidden_size : int\linput_proj : Linear, NoneType\linput_size : int\lnum_layers : int\loutput_size : int\lrnn : GRU\lrnn_arch : str\lu : Linear\luse_attn : bool\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.strategy.rule_strategy.RandomOrderStrategy" [color="black", fontcolor="black", label="{RandomOrderStrategy|direction : int\lmarket : str\lsample_ratio : float\ltrade_range : Union[Tuple[int, int], TradeRange]\lvolume\lvolume_df\lvolume_ratio : float\l|generate_trade_decision(execute_result)\l}", shape="record", style="solid"];
"qlib.data.ops.Rank" [color="black", fontcolor="black", label="{Rank|\l|}", shape="record", style="solid"];
"qlib.contrib.report.data.ana.RawFeaAna" [color="black", fontcolor="black", label="{RawFeaAna|ylim : tuple\l|calc_stat_values()\lplot_single(col, ax)\l}", shape="record", style="solid"];
"qlib.workflow.record_temp.RecordTemp" [color="black", fontcolor="black", label="{RecordTemp|artifact_path : NoneType\ldepend_cls : NoneType\lrecorder\l|check(include_self: bool, parents: bool)\lgenerate()\lget_path(cls, path)\llist()\lload(name: str, parents: bool)\lsave()\l}", shape="record", style="solid"];
"qlib.workflow.online.update.RecordUpdater" [color="black", fontcolor="black", label="{RecordUpdater|logger\lrecord\l|update()\l}", shape="record", style="solid"];
"qlib.workflow.recorder.Recorder" [color="black", fontcolor="black", label="{Recorder|STATUS_FA : str\lSTATUS_FI : str\lSTATUS_R : str\lSTATUS_S : str\lend_time : NoneType\lexperiment_id\lid : NoneType\linfo\lname\lrecorder_name\lstart_time : NoneType\lstatus : str\l|delete_tags()\lend_run()\llist_artifacts(artifact_path: str)\llist_metrics()\llist_params()\llist_tags()\lload_object(name)\llog_metrics(step)\llog_params()\lsave_objects(local_path, artifact_path)\lset_recorder_name(rname)\lset_tags()\lstart_run()\l}", shape="record", style="solid"];
"qlib.workflow.task.collect.RecorderCollector" [color="black", fontcolor="black", label="{RecorderCollector|ART_KEY_RAW : str\lartifacts_key : NoneType, list\lartifacts_path : dict\lexperiment\llist_kwargs : dict\lrec_filter_func : NoneType\lrec_key_func : NoneType\lstatus : Iterable\l|collect(artifacts_key, rec_filter_func, only_exist): dict\lget_exp_name(): str\l}", shape="record", style="solid"];
"qlib.utils.exceptions.RecorderInitializationError" [color="black", fontcolor="red", label="{RecorderInitializationError|\l|}", shape="record", style="solid"];
"qlib.workflow.RecorderWrapper" [color="black", fontcolor="black", label="{RecorderWrapper|\l|register(provider)\l}", shape="record", style="solid"];
"qlib.data.ops.Ref" [color="black", fontcolor="black", label="{Ref|\l|get_extended_window_size()\lget_longest_back_rolling()\l}", shape="record", style="solid"];
"qlib.data.ops.Resi" [color="black", fontcolor="black", label="{Resi|\l|}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_add.RevGrad" [color="black", fontcolor="black", label="{RevGrad|gamma : float\lgamma_clip\l|forward(input_)\lstep_alpha()\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_add.RevGradFunc" [color="black", fontcolor="black", label="{RevGradFunc|\l|backward(ctx, grad_output)\lforward(ctx, input_, alpha_)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_adarnn.ReverseLayerF" [color="black", fontcolor="black", label="{ReverseLayerF|\l|backward(ctx, grad_output)\lforward(ctx, x, alpha)\l}", shape="record", style="solid"];
"qlib.data.dataset.weight.Reweighter" [color="black", fontcolor="black", label="{Reweighter|\l|reweight(data: object): object\l}", shape="record", style="solid"];
"qlib.model.riskmodel.base.RiskModel" [color="black", fontcolor="black", label="{RiskModel|FILL_NAN : str\lIGNORE_NAN : str\lMASK_NAN : str\lassume_centered : bool\lnan_option : str\lscale_return : bool\l|predict(X: Union[pd.Series, pd.DataFrame, np.ndarray], return_corr: bool, is_price: bool, return_decomposed_components): Union[pd.DataFrame, np.ndarray, tuple]\l}", shape="record", style="solid"];
"qlib.data.dataset.processor.RobustZScoreNorm" [color="black", fontcolor="black", label="{RobustZScoreNorm|clip_outlier : bool\lcols\lfields_group : NoneType\lfit_end_time\lfit_start_time\lmean_train : ndarray\lstd_train : ndarray\l|fit(df)\l}", shape="record", style="solid"];
"qlib.data.ops.Rolling" [color="black", fontcolor="black", label="{Rolling|N\lfeature\lfunc\l|get_extended_window_size()\lget_longest_back_rolling()\l}", shape="record", style="solid"];
"qlib.model.ens.ensemble.RollingEnsemble" [color="black", fontcolor="black", label="{RollingEnsemble|\l|}", shape="record", style="solid"];
"qlib.workflow.task.gen.RollingGen" [color="black", fontcolor="black", label="{RollingGen|ROLL_EX : str\lROLL_SD : str\lds_extra_mod_func : Union[None, Callable]\lrtype : str\lstep : int\lta\ltask_copy_func : Callable\ltest_key : str\ltrain_key : str\ltrunc_days : Optional[int]\l|gen_following_tasks(task: dict, test_end): List[dict]\lgenerate(task: dict): List[dict]\l}", shape="record", style="solid"];
"qlib.model.ens.group.RollingGroup" [color="black", fontcolor="black", label="{RollingGroup|\l|group(rolling_dict: dict): dict\l}", shape="record", style="solid"];
"qlib.workflow.online.strategy.RollingStrategy" [color="black", fontcolor="black", label="{RollingStrategy|exp_name\lrg\lta\ltask_template : Union[dict, List[dict]]\ltool\l|first_tasks(): List[dict]\lget_collector(process_list, rec_key_func, rec_filter_func, artifacts_key)\lprepare_tasks(cur_time): List[dict]\l}", shape="record", style="solid"];
"qlib.data.ops.Rsquare" [color="black", fontcolor="black", label="{Rsquare|\l|}", shape="record", style="solid"];
"qlib.contrib.strategy.rule_strategy.SBBStrategyBase" [color="black", fontcolor="black", label="{SBBStrategyBase|TREND_LONG : int\lTREND_MID : int\lTREND_SHORT : int\ltrade_amount : dict\ltrade_trend : dict\l|generate_trade_decision(execute_result)\lreset(outer_trade_decision: BaseTradeDecision)\l}", shape="record", style="solid"];
"qlib.contrib.strategy.rule_strategy.SBBStrategyEMA" [color="black", fontcolor="black", label="{SBBStrategyEMA|freq : str\linstruments : str\lsignal : dict\l|reset_level_infra(level_infra)\l}", shape="record", style="solid"];
"qlib.contrib.data.utils.sepdf.SDFLoc" [color="black", fontcolor="black", label="{SDFLoc|axis : NoneType\ljoin\l|}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_sfm.SFM" [color="black", fontcolor="black", label="{SFM|batch_size : int\ld_feat : int\ldevice\ldropout_U : float\ldropout_W : float\learly_stop : int\leval_steps : int\lfitted : bool\lfreq_dim : int\lhidden_size : int\llogger\lloss : str\llr : float\lmetric : str\ln_epochs : int\loptimizer : str\loutput_dim : int\lseed : NoneType\lsfm_model\ltrain_optimizer : Adam, SGD\luse_gpu\l|fit(dataset: DatasetH, evals_result, save_path)\lloss_fn(pred, label)\lmetric_fn(pred, label)\lmse(pred, label)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\ltest_epoch(data_x, data_y)\ltrain_epoch(x_train, y_train)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_sfm.SFM_Model" [color="black", fontcolor="black", label="{SFM_Model|U_a : Parameter\lU_c : Parameter\lU_fre : Parameter\lU_i : Parameter\lU_o : Parameter\lU_ste : Parameter\lW_c : Parameter\lW_fre : Parameter\lW_i : Parameter\lW_o : Parameter\lW_p : Parameter\lW_ste : Parameter\lactivation : Tanh\lb_a : Parameter\lb_c : Parameter\lb_fre : Parameter\lb_i : Parameter\lb_o : Parameter\lb_p : Parameter\lb_ste : Parameter\ldevice : str\ldropout_U : float\ldropout_W : float\lfc_out : Linear\lfreq_dim : int\lhidden_dim : int\linner_activation : Hardsigmoid\linput_dim : int\loutput_dim : int\lstates : list\l|forward(input)\lget_constants(x)\linit_states(x)\l}", shape="record", style="solid"];
"qlib.contrib.report.graph.ScatterGraph" [color="black", fontcolor="black", label="{ScatterGraph|\l|}", shape="record", style="solid"];
"qlib.contrib.online.online_model.ScoreFileModel" [color="black", fontcolor="black", label="{ScoreFileModel|pred : TextFileReader\l|fit(x_train, y_train, x_valid, y_valid, w_train, w_valid)\lget_data_with_date(date)\lpredict(x_test)\lsave(fname)\lscore(x_test)\l}", shape="record", style="solid"];
"qlib.contrib.data.utils.sepdf.SepDataFrame" [color="black", fontcolor="black", label="{SepDataFrame|columns\lindex\ljoin : str\lloc\l|apply_each(method: str, skip_align)\lcopy()\ldroplevel()\lmerge(df_dict: str, join)\lsort_index()\l}", shape="record", style="solid"];
"qlib.utils.serial.Serializable" [color="black", fontcolor="black", label="{Serializable|FLAG_KEY : str\lconfig_attr : list\ldefault_dump_all : bool\ldump_all\lexclude_attr : list\linclude_attr : list\lpickle_backend : str\l|config(recursive)\lgeneral_dump(obj: Union[Path, str], path)\lget_backend(cls)\lload(cls, filepath)\lto_pickle(path: Union[Path, str])\l}", shape="record", style="solid"];
"qlib.data.filter.SeriesDFilter" [color="black", fontcolor="black", label="{SeriesDFilter|filter_end_time : NoneType\lfilter_freq : str\lfilter_start_time : NoneType\lkeep : bool\l|filter_main(instruments, start_time, end_time)\l}", shape="record", style="solid"];
"qlib.model.riskmodel.shrink.ShrinkCovEstimator" [color="black", fontcolor="black", label="{ShrinkCovEstimator|SHR_LW : str\lSHR_OAS : str\lTGT_CONST_CORR : str\lTGT_CONST_VAR : str\lTGT_SINGLE_FACTOR : str\lalpha : Union[str, float]\ltarget : Union[str, np.ndarray]\l|}", shape="record", style="solid"];
"qlib.workflow.record_temp.SigAnaRecord" [color="black", fontcolor="black", label="{SigAnaRecord|ana_long_short : bool\lann_scaler : int\lartifact_path : str\ldepend_cls\llabel_col : int\l|list()\l}", shape="record", style="solid"];
"qlib.data.ops.Sign" [color="black", fontcolor="black", label="{Sign|\l|}", shape="record", style="solid"];
"qlib.backtest.signal.Signal" [color="black", fontcolor="black", label="{Signal|\l|get_signal(start_time, end_time): Union[pd.Series, pd.DataFrame, None]\l}", shape="record", style="solid"];
"qlib.contrib.workflow.record_temp.SignalMseRecord" [color="black", fontcolor="black", label="{SignalMseRecord|artifact_path : str\ldepend_cls\l|generate()\llist()\l}", shape="record", style="solid"];
"qlib.workflow.record_temp.SignalRecord" [color="black", fontcolor="black", label="{SignalRecord|dataset : NoneType\lmodel : NoneType\l|generate()\lgenerate_label(dataset)\llist()\l}", shape="record", style="solid"];
"qlib.backtest.signal.SignalWCache" [color="black", fontcolor="black", label="{SignalWCache|signal_cache\l|get_signal(start_time, end_time): Union[pd.Series, pd.DataFrame]\l}", shape="record", style="solid"];
"qlib.data.cache.SimpleDatasetCache" [color="black", fontcolor="black", label="{SimpleDatasetCache|local_cache_path : Path\l|}", shape="record", style="solid"];
"qlib.backtest.executor.SimulatorExecutor" [color="black", fontcolor="black", label="{SimulatorExecutor|TT_PARAL : str\lTT_SERIAL : str\ldeal_day\ldealt_order_amount : defaultdict\ltrade_type : str\l|}", shape="record", style="solid"];
"qlib.utils.index_data.SingleData" [color="black", fontcolor="black", label="{SingleData|\l|add(other, fill_value)\lreindex(index: Index, fill_value)\lto_dict()\lto_series()\l}", shape="record", style="solid"];
"qlib.model.ens.ensemble.SingleKeyEnsemble" [color="black", fontcolor="black", label="{SingleKeyEnsemble|\l|}", shape="record", style="solid"];
"qlib.contrib.meta.data_selection.utils.SingleMetaBase" [color="black", fontcolor="black", label="{SingleMetaBase|clip_method : str\lclip_weight : NoneType\l|is_enabled()\l}", shape="record", style="solid"];
"qlib.backtest.high_performance_ds.SingleMetric" [color="black", fontcolor="black", label="{SingleMetric|metric\l|}", shape="record", style="solid"];
"qlib.data.ops.Skew" [color="black", fontcolor="black", label="{Skew|\l|}", shape="record", style="solid"];
"qlib.data.ops.Slope" [color="black", fontcolor="black", label="{Slope|\l|}", shape="record", style="solid"];
"qlib.contrib.strategy.cost_control.SoftTopkStrategy" [color="black", fontcolor="black", label="{SoftTopkStrategy|buy_method : str\lmax_sold_weight : float\lrisk_degree : float\ltopk\l|generate_target_weight_position(score, current, trade_start_time, trade_end_time)\lget_risk_degree(trade_step)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tabnet.SparsemaxFunction" [color="black", fontcolor="black", label="{SparsemaxFunction|\l|backward(ctx, grad_output)\lforward(ctx, input, dim)\lthreshold_and_support(input, dim)\l}", shape="record", style="solid"];
"qlib.rl.interpreter.StateInterpreter" [color="black", fontcolor="black", label="{StateInterpreter|\l|interpret(execute_result)\l}", shape="record", style="solid"];
"qlib.data.dataset.loader.StaticDataLoader" [color="black", fontcolor="black", label="{StaticDataLoader|include_attr : list\ljoin : str\l|load(instruments, start_time, end_time): \l}", shape="record", style="solid"];
"qlib.data.ops.Std" [color="black", fontcolor="black", label="{Std|\l|}", shape="record", style="solid"];
"qlib.model.riskmodel.structured.StructuredCovEstimator" [color="black", fontcolor="black", label="{StructuredCovEstimator|DEFAULT_NAN_OPTION : str\lFACTOR_MODEL_FA : str\lFACTOR_MODEL_PCA : str\lnum_factors : int\lsolver : PCA, FactorAnalysis\l|}", shape="record", style="solid"];
"qlib.data.ops.Sub" [color="black", fontcolor="black", label="{Sub|\l|}", shape="record", style="solid"];
"qlib.contrib.report.graph.SubplotsGraph" [color="black", fontcolor="black", label="{SubplotsGraph|figure\l|}", shape="record", style="solid"];
"qlib.data.ops.Sum" [color="black", fontcolor="black", label="{Sum|\l|}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tcn.TCN" [color="black", fontcolor="black", label="{TCN|batch_size : int\ld_feat : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\lkernel_size : int\llogger\lloss : str\llr : float\lmetric : str\ln_chans : int\ln_epochs : int\lnum_layers : int\loptimizer : str\lseed : NoneType\ltcn_model\ltrain_optimizer : SGD, Adam\luse_gpu\l|fit(dataset: DatasetH, evals_result, save_path)\lloss_fn(pred, label)\lmetric_fn(pred, label)\lmse(pred, label)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\ltest_epoch(data_x, data_y)\ltrain_epoch(x_train, y_train)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tcn_ts.TCN" [color="black", fontcolor="black", label="{TCN|TCN_model\lbatch_size : int\ld_feat : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\lkernel_size : int\llogger\lloss : str\llr : float\lmetric : str\ln_chans : int\ln_epochs : int\ln_jobs : int\lnum_layers : int\loptimizer : str\lseed : NoneType\ltrain_optimizer : SGD, Adam\luse_gpu\l|fit(dataset, evals_result, save_path)\lloss_fn(pred, label)\lmetric_fn(pred, label)\lmse(pred, label)\lpredict(dataset)\ltest_epoch(data_loader)\ltrain_epoch(data_loader)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tcn.TCNModel" [color="black", fontcolor="black", label="{TCNModel|linear : Linear\lnum_input\ltcn\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tcn_ts.TCNModel" [color="black", fontcolor="black", label="{TCNModel|linear : Linear\lnum_input\ltcn\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tcts.TCTS" [color="black", fontcolor="black", label="{TCTS|batch_size : int\ld_feat : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\lfore_lr : float\lfore_model\lfore_optimizer : Adam, SGD\lhidden_size : int\linput_dim : int\llogger\lloss : str\llowest_valid_performance : float\lmode : str\ln_epochs : int\lnum_layers : int\loutput_dim : int\lseed : NoneType\lsteps : int\ltarget_label : int\luse_gpu : bool\lweight_lr : float\lweight_model\lweight_optimizer : Adam, SGD\l|fit(dataset: DatasetH, verbose, save_path)\lloss_fn(pred, label, weight)\lpredict(dataset)\ltest_epoch(data_x, data_y)\ltrain_epoch(x_train, y_train, x_valid, y_valid)\ltraining(x_train, y_train, x_valid, y_valid, x_test, y_test, verbose, save_path)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tra.TRA" [color="black", fontcolor="black", label="{TRA|fc : Linear\lnum_states : int\lpredictors : Linear\lrnn_arch : str\lrouter : GRU\lsrc_info : str\ltau : float\l|forward(hidden, hist_loss)\lreset_parameters()\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tra.TRAModel" [color="black", fontcolor="black", label="{TRAModel|alpha : float\learly_stop : int\leval_test : bool\leval_train : bool\lfitted : bool\lfreeze_model : bool\lfreeze_predictors : bool\lglobal_step : int\linit_state : NoneType\llamb : float\llogdir : NoneType\llogger\llr : float\lmax_steps_per_epoch : NoneType\lmodel\lmodel_config\lmodel_type : str\ln_epochs : int\loptimizer : Adam\lpretrain : bool\lreset_router : bool\lrho : float\lseed : NoneType\ltra : NoneType\ltra_config\ltransport_fn\ltransport_method : str\lupdate_freq : int\luse_daily_transport\l|fit(dataset, evals_result)\lpredict(dataset, segment)\ltest_epoch(epoch, data_set, return_pred, prefix, is_pretrain)\ltrain_epoch(epoch, data_set, is_pretrain)\l}", shape="record", style="solid"];
"qlib.data.ops.TResample" [color="black", fontcolor="black", label="{TResample|feature\lfreq\lfunc\l|}", shape="record", style="solid"];
"qlib.data.dataset.TSDataSampler" [color="black", fontcolor="black", label="{TSDataSampler|data\ldata_arr : ndarray\ldata_index\lempty\lend\lend_idx\lfillna_type : str\lflt_data\lidx_arr : ndarray\lidx_df\lidx_map : ndarray, dict\lnan_idx : int\lstart\lstart_idx\lstep_len : int\l|build_index(data): Tuple[pd.DataFrame, dict]\lconfig()\lflt_idx_map(flt_data, idx_map)\lget_index()\lidx_map2arr(idx_map)\l}", shape="record", style="solid"];
"qlib.data.dataset.TSDatasetH" [color="black", fontcolor="black", label="{TSDatasetH|DEFAULT_STEP_LEN : int\lcal\lstep_len : int\l|config()\lsetup_data()\l}", shape="record", style="solid"];
"qlib.contrib.strategy.rule_strategy.TWAPStrategy" [color="black", fontcolor="black", label="{TWAPStrategy|trade_amount_remain : dict\l|generate_trade_decision(execute_result)\lreset(outer_trade_decision: BaseTradeDecision)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tabnet.TabNet" [color="black", fontcolor="black", label="{TabNet|bn : BatchNorm1d\lfc : Linear\lfirst_step\ln_d : int\lshared : NoneType, ModuleList\lsteps : ModuleList\l|forward(x, priors)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tabnet.TabNet_Decoder" [color="black", fontcolor="black", label="{TabNet_Decoder|n_steps\lout_dim\lshared : NoneType, ModuleList\lsteps : ModuleList\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tabnet.TabnetModel" [color="black", fontcolor="black", label="{TabnetModel|batch_size : int\ld_feat : int\ldevice : str\learly_stop : int\lfinal_out_dim : int\lfitted : bool\llogger\lloss : str\llr : float\lmetric : str\ln_epochs : int\loptimizer : str\lout_dim : int\lpretrain : bool\lpretrain_file : bytes, str, NoneType\lpretrain_loss : str\lpretrain_n_epochs : int\lpretrain_optimizer : Adam, SGD\lps : float\lseed : int\ltabnet_decoder : NoneType\ltabnet_model : NoneType\ltrain_optimizer : SGD, Adam\luse_gpu\l|fit(dataset: DatasetH, evals_result, save_path)\lloss_fn(pred, label)\lmetric_fn(pred, label)\lmse(pred, label)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\lpretrain_epoch(x_train)\lpretrain_fn(dataset, pretrain_file)\lpretrain_loss_fn(f_hat, f, S)\lpretrain_test_epoch(x_train)\ltest_epoch(data_x, data_y)\ltrain_epoch(x_train, y_train)\l}", shape="record", style="solid"];
"qlib.data.dataset.processor.TanhProcess" [color="black", fontcolor="black", label="{TanhProcess|\l|}", shape="record", style="solid"];
"qlib.workflow.task.gen.TaskGen" [color="black", fontcolor="black", label="{TaskGen|\l|generate(task: dict): List[dict]\l}", shape="record", style="solid"];
"qlib.workflow.task.manage.TaskManager" [color="black", fontcolor="black", label="{TaskManager|ENCODE_FIELDS_PREFIX : list\lSTATUS_DONE : str\lSTATUS_PART_DONE : str\lSTATUS_RUNNING : str\lSTATUS_WAITING : str\llogger\ltask_pool : Collection\l|commit_task_res(task, res, status)\lcreate_task(task_def_l, dry_run, print_nt): List[str]\lfetch_task(query, status): dict\linsert_task(task)\linsert_task_def(task_def)\llist(): list\lprioritize(task, priority: int)\lquery(query, decode)\lre_query(_id): dict\lremove(query)\lreplace_task(task, new_task)\lreset_status(query, status)\lreset_waiting(query)\lreturn_task(task, status)\lsafe_fetch_task(query, status)\ltask_fetcher_iter(query)\ltask_stat(query): dict\lwait(query)\l}", shape="record", style="solid"];
"qlib.contrib.model.tcn.TemporalBlock" [color="black", fontcolor="black", label="{TemporalBlock|chomp1\lchomp2\lconv1 : Conv1d\lconv2 : Conv1d\ldownsample : Conv1d, NoneType\ldropout1 : Dropout\ldropout2 : Dropout\lnet : Sequential\lrelu : ReLU\lrelu1 : ReLU\lrelu2 : ReLU\l|forward(x)\linit_weights()\l}", shape="record", style="solid"];
"qlib.contrib.model.tcn.TemporalConvNet" [color="black", fontcolor="black", label="{TemporalConvNet|network : Sequential\l|forward(x)\l}", shape="record", style="solid"];
"qlib.tests.TestAutoData" [color="black", fontcolor="black", label="{TestAutoData|provider_uri : str\lprovider_uri_1day : str\lprovider_uri_1min : str\l|setUpClass(cls, enable_1d_type, enable_1min): \l}", shape="record", style="solid"];
"qlib.tests.TestOperatorData" [color="black", fontcolor="black", label="{TestOperatorData|\l|setUpClass(cls, enable_1d_type, enable_1min): \l}", shape="record", style="solid"];
"qlib.workflow.task.utils.TimeAdjuster" [color="black", fontcolor="black", label="{TimeAdjuster|SHIFT_EX : str\lSHIFT_SD : str\lcals\l|align_idx(time_point, tp_type): int\lalign_seg(segment: Union[dict, tuple]): Union[dict, tuple]\lalign_time(time_point, tp_type): \lcal_interval(time_point_A, time_point_B): int\lget(idx: int)\lmax(): \lset_end_time(end_time)\lshift(seg: tuple, step: int, rtype): tuple\ltruncate(segment: tuple, test_start, days: int): tuple\l}", shape="record", style="solid"];
"qlib.log.TimeInspector" [color="black", fontcolor="black", label="{TimeInspector|time_marks : list\ltimer_logger\l|get_cost_time(cls)\llog_cost_time(cls, info)\llogt(cls, name, show_start)\lpop_time_mark(cls)\lset_time_mark(cls)\l}", shape="record", style="solid"];
"qlib.contrib.meta.data_selection.model.TimeReweighter" [color="black", fontcolor="black", label="{TimeReweighter|time_weight : Series\l|reweight(data: Union[pd.DataFrame, pd.Series])\l}", shape="record", style="solid"];
"qlib.contrib.meta.data_selection.net.TimeWeightMeta" [color="black", fontcolor="black", label="{TimeWeightMeta|k : Parameter\llinear : Linear\l|forward(time_perf, time_belong, return_preds)\l}", shape="record", style="solid"];
"qlib.contrib.strategy.signal_strategy.TopkDropoutStrategy" [color="black", fontcolor="black", label="{TopkDropoutStrategy|hold_thresh : int\lmethod_buy : str\lmethod_sell : str\ln_drop\lonly_tradable : bool\ltopk\l|generate_trade_decision(execute_result)\l}", shape="record", style="solid"];
"qlib.backtest.utils.TradeCalendarManager" [color="black", fontcolor="black", label="{TradeCalendarManager|end_index\lend_time : NoneType\lfreq\llevel_infra : str\lstart_index\lstart_time : NoneType\ltrade_len\ltrade_step : int\l|finished()\lget_all_time()\lget_data_cal_range(rtype: str): Tuple[int, int]\lget_freq()\lget_range_idx(start_time, end_time): Tuple[int, int]\lget_step_time(trade_step, shift)\lget_trade_len()\lget_trade_step()\lreset(freq, start_time, end_time)\lstep()\l}", shape="record", style="solid"];
"qlib.backtest.decision.TradeDecisionWO" [color="black", fontcolor="black", label="{TradeDecisionWO|order_list : List[Order]\l|get_decision(): List[object]\l}", shape="record", style="solid"];
"qlib.backtest.decision.TradeRange" [color="black", fontcolor="black", label="{TradeRange|\l|clip_time_range(start_time, end_time): Tuple[pd.Timestamp, pd.Timestamp]\l}", shape="record", style="solid"];
"qlib.backtest.decision.TradeRangeByTime" [color="black", fontcolor="black", label="{TradeRangeByTime|end_time\lstart_time\l|clip_time_range(start_time, end_time): Tuple[pd.Timestamp, pd.Timestamp]\l}", shape="record", style="solid"];
"qlib.model.trainer.Trainer" [color="black", fontcolor="black", label="{Trainer|delay : bool\l|end_train(models: list): list\lhas_worker(): bool\lis_delay(): bool\ltrain(tasks: list): list\lworker()\l}", shape="record", style="solid"];
"qlib.model.trainer.TrainerR" [color="black", fontcolor="black", label="{TrainerR|STATUS_BEGIN : str\lSTATUS_END : str\lSTATUS_KEY : str\lexperiment_name : Optional[str]\ltrain_func : Callable\l|end_train(models: list): List[Recorder]\ltrain(tasks: list, train_func: Callable, experiment_name: str): List[Recorder]\l}", shape="record", style="solid"];
"qlib.model.trainer.TrainerRM" [color="black", fontcolor="black", label="{TrainerRM|STATUS_BEGIN : str\lSTATUS_END : str\lSTATUS_KEY : str\lTM_ID : str\lexperiment_name : Optional[str]\lskip_run_task : bool\ltask_pool : Optional[str]\ltrain_func\l|end_train(recs: list): List[Recorder]\lhas_worker(): bool\ltrain(tasks: list, train_func: Callable, experiment_name: str, before_status: str, after_status: str): List[Recorder]\lworker(train_func: Callable, experiment_name: str)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_adarnn.TransferLoss" [color="black", fontcolor="black", label="{TransferLoss|input_dim : int\lloss_type : str\l|compute(X, Y)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_localformer_ts.Transformer" [color="black", fontcolor="black", label="{Transformer|d_feat : int\ldecoder_layer : Linear\ldevice : NoneType\lencoder_layer : TransformerEncoderLayer\lfeature_layer : Linear\lpos_encoder\lrnn : GRU\ltransformer_encoder\l|forward(src)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_transformer.Transformer" [color="black", fontcolor="black", label="{Transformer|d_feat : int\ldecoder_layer : Linear\ldevice : NoneType\lencoder_layer : TransformerEncoderLayer\lfeature_layer : Linear\lpos_encoder\ltransformer_encoder : TransformerEncoder\l|forward(src)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_localformer.Transformer" [color="black", fontcolor="black", label="{Transformer|d_feat : int\ldecoder_layer : Linear\ldevice : NoneType\lencoder_layer : TransformerEncoderLayer\lfeature_layer : Linear\lpos_encoder\lrnn : GRU\ltransformer_encoder\l|forward(src)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_tra.Transformer" [color="black", fontcolor="black", label="{Transformer|encoder : TransformerEncoder\lhidden_size : int\linput_proj : Linear\linput_size : int\lnum_heads : int\lnum_layers : int\loutput_size : int\lpe\l|forward(x)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_transformer_ts.Transformer" [color="black", fontcolor="black", label="{Transformer|d_feat : int\ldecoder_layer : Linear\ldevice : NoneType\lencoder_layer : TransformerEncoderLayer\lfeature_layer : Linear\lpos_encoder\ltransformer_encoder : TransformerEncoder\l|forward(src)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_transformer.TransformerModel" [color="black", fontcolor="black", label="{TransformerModel|batch_size : int\ld_model : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\llogger\lloss : str\llr : float\lmetric : str\lmodel\ln_epochs : int\ln_jobs : int\loptimizer : str\lreg : float\lseed : NoneType\ltrain_optimizer : SGD, Adam\luse_gpu\l|fit(dataset: DatasetH, evals_result, save_path)\lloss_fn(pred, label)\lmetric_fn(pred, label)\lmse(pred, label)\lpredict(dataset: DatasetH, segment: Union[Text, slice])\ltest_epoch(data_x, data_y)\ltrain_epoch(x_train, y_train)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_transformer_ts.TransformerModel" [color="black", fontcolor="black", label="{TransformerModel|batch_size : int\ld_model : int\ldevice\ldropout : float\learly_stop : int\lfitted : bool\llogger\lloss : str\llr : float\lmetric : str\lmodel\ln_epochs : int\ln_jobs : int\loptimizer : str\lreg : float\lseed : NoneType\ltrain_optimizer : SGD, Adam\luse_gpu\l|fit(dataset: DatasetH, evals_result, save_path)\lloss_fn(pred, label)\lmetric_fn(pred, label)\lmse(pred, label)\lpredict(dataset)\ltest_epoch(data_loader)\ltrain_epoch(data_loader)\l}", shape="record", style="solid"];
"qlib.contrib.tuner.tuner.Tuner" [color="black", fontcolor="black", label="{Tuner|best_params : NoneType\lbest_res : NoneType\lex_dir\llogger\lmax_evals\loptim_config\lspace\ltuner_config\l|objective(params)\lsave_local_best_params()\lsetup_space()\ltune()\l}", shape="record", style="solid"];
"qlib.contrib.tuner.config.TunerConfigManager" [color="black", fontcolor="black", label="{TunerConfigManager|backtest_config\lconfig\lconfig_path\ldata_config\loptim_config\lpipeline_config\lpipeline_ex_config\lqlib_client_config\ltime_config\l|}", shape="record", style="solid"];
"qlib.contrib.online.user.User" [color="black", fontcolor="black", label="{User|account\llogger\lmodel\lstrategy\lverbose : bool\l|get_latest_trading_date()\linit_state(date)\lshowReport(benchmark)\l}", shape="record", style="solid"];
"qlib.contrib.online.manager.UserManager" [color="black", fontcolor="black", label="{UserManager|data_path : Path\lsave_report : bool\luser_record : TextFileReader, NoneType\lusers : dict\lusers_file\l|add_user(user_id, config_file, add_date)\lload_user(user_id)\lload_users()\lremove_user(user_id)\lsave_user_data(user_id)\l}", shape="record", style="solid"];
"qlib.contrib.report.data.ana.ValueCNT" [color="black", fontcolor="black", label="{ValueCNT|ratio : bool\lylim : tuple\l|calc_stat_values()\lplot_single(col, ax)\l}", shape="record", style="solid"];
"qlib.data.ops.Var" [color="black", fontcolor="black", label="{Var|\l|}", shape="record", style="solid"];
"qlib.data.ops.WMA" [color="black", fontcolor="black", label="{WMA|\l|}", shape="record", style="solid"];
"qlib.contrib.strategy.signal_strategy.WeightStrategyBase" [color="black", fontcolor="black", label="{WeightStrategyBase|order_generator\l|generate_target_weight_position(score, current, trade_start_time, trade_end_time)\lgenerate_trade_decision(execute_result)\l}", shape="record", style="solid"];
"qlib.utils.Wrapper" [color="black", fontcolor="black", label="{Wrapper|\l|register(provider)\l}", shape="record", style="solid"];
"qlib.contrib.model.xgboost.XGBModel" [color="black", fontcolor="black", label="{XGBModel|model : NoneType\l|fit(dataset: DatasetH, num_boost_round, early_stopping_rounds, verbose_eval, evals_result, reweighter)\lget_feature_importance(): \lpredict(dataset: DatasetH, segment: Union[Text, slice])\l}", shape="record", style="solid"];
"qlib.data.dataset.processor.ZScoreNorm" [color="black", fontcolor="black", label="{ZScoreNorm|cols\lfields_group : NoneType\lfit_end_time\lfit_start_time\lignore\lmean_train : ndarray\lstd_train\l|fit(df)\l}", shape="record", style="solid"];
"qlib.contrib.model.pytorch_adarnn.data_loader" [color="black", fontcolor="black", label="{data_loader|df_feature\ldf_index\ldf_label_reg\l|}", shape="record", style="solid"];
"qlib.backtest.decision.EmptyTradeDecision" -> "qlib.backtest.decision.BaseTradeDecision" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.decision.IdxTradeRange" -> "qlib.backtest.decision.TradeRange" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.decision.TradeDecisionWO" -> "qlib.backtest.decision.BaseTradeDecision" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.decision.TradeRangeByTime" -> "qlib.backtest.decision.TradeRange" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.executor.NestedExecutor" -> "qlib.backtest.executor.BaseExecutor" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.executor.SimulatorExecutor" -> "qlib.backtest.executor.BaseExecutor" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.high_performance_ds.NumpyOrderIndicator" -> "qlib.backtest.high_performance_ds.BaseOrderIndicator" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.high_performance_ds.NumpyQuote" -> "qlib.backtest.high_performance_ds.BaseQuote" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.high_performance_ds.PandasOrderIndicator" -> "qlib.backtest.high_performance_ds.BaseOrderIndicator" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.high_performance_ds.PandasQuote" -> "qlib.backtest.high_performance_ds.BaseQuote" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.high_performance_ds.PandasSingleMetric" -> "qlib.backtest.high_performance_ds.SingleMetric" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.high_performance_ds.SingleMetric" -> "qlib.backtest.high_performance_ds.BaseSingleMetric" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.position.InfPosition" -> "qlib.backtest.position.BasePosition" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.position.Position" -> "qlib.backtest.position.BasePosition" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.signal.ModelSignal" -> "qlib.backtest.signal.SignalWCache" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.signal.SignalWCache" -> "qlib.backtest.signal.Signal" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.utils.CommonInfrastructure" -> "qlib.backtest.utils.BaseInfrastructure" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.utils.LevelInfrastructure" -> "qlib.backtest.utils.BaseInfrastructure" [arrowhead="empty", arrowtail="none"];
"qlib.config.QlibConfig" -> "qlib.config.Config" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.data.data.ArcticFeatureProvider" -> "qlib.data.data.FeatureProvider" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.data.handler.Alpha158" -> "qlib.data.dataset.handler.DataHandlerLP" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.data.handler.Alpha158vwap" -> "qlib.contrib.data.handler.Alpha158" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.data.handler.Alpha360" -> "qlib.data.dataset.handler.DataHandlerLP" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.data.handler.Alpha360vwap" -> "qlib.contrib.data.handler.Alpha360" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.data.processor.ConfigSectionProcessor" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.meta.data_selection.dataset.MetaDatasetDS" -> "qlib.model.meta.dataset.MetaTaskDataset" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.meta.data_selection.dataset.MetaTaskDS" -> "qlib.model.meta.task.MetaTask" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.meta.data_selection.model.MetaModelDS" -> "qlib.model.meta.model.MetaTaskModel" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.meta.data_selection.model.TimeReweighter" -> "qlib.data.dataset.weight.Reweighter" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.meta.data_selection.net.TimeWeightMeta" -> "qlib.contrib.meta.data_selection.utils.SingleMetaBase" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.catboost_model.CatBoostModel" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.catboost_model.CatBoostModel" -> "qlib.model.interpret.base.FeatureInt" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.double_ensemble.DEnsembleModel" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.double_ensemble.DEnsembleModel" -> "qlib.model.interpret.base.FeatureInt" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.gbdt.LGBModel" -> "qlib.model.base.ModelFT" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.gbdt.LGBModel" -> "qlib.model.interpret.base.LightGBMFInt" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.highfreq_gdbt_model.HFLGBModel" -> "qlib.model.base.ModelFT" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.highfreq_gdbt_model.HFLGBModel" -> "qlib.model.interpret.base.LightGBMFInt" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.linear.LinearModel" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_adarnn.ADARNN" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_add.ADD" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_alstm.ALSTM" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_alstm_ts.ALSTM" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_gats.GATs" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_gats_ts.GATs" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_gru.GRU" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_gru_ts.GRU" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_localformer.LocalformerModel" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_localformer_ts.LocalformerModel" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_lstm.LSTM" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_lstm_ts.LSTM" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_nn.DNNModelPytorch" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_sfm.SFM" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_tabnet.TabnetModel" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_tcn.TCN" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_tcn_ts.TCN" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_tcts.TCTS" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_tra.TRAModel" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_transformer.TransformerModel" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.pytorch_transformer_ts.TransformerModel" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.xgboost.XGBModel" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.model.xgboost.XGBModel" -> "qlib.model.interpret.base.FeatureInt" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.ops.high_freq.DayCumsum" -> "qlib.data.ops.ElemOperator" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.data.ana.CombFeaAna" -> "qlib.contrib.report.data.base.FeaAnalyser" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.data.ana.FeaACAna" -> "qlib.contrib.report.data.base.FeaAnalyser" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.data.ana.FeaDistAna" -> "qlib.contrib.report.data.ana.NumFeaAnalyser" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.data.ana.FeaInfAna" -> "qlib.contrib.report.data.ana.NumFeaAnalyser" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.data.ana.FeaMeanStd" -> "qlib.contrib.report.data.ana.NumFeaAnalyser" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.data.ana.FeaNanAna" -> "qlib.contrib.report.data.base.FeaAnalyser" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.data.ana.FeaNanAnaRatio" -> "qlib.contrib.report.data.base.FeaAnalyser" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.data.ana.FeaSkewTurt" -> "qlib.contrib.report.data.ana.NumFeaAnalyser" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.data.ana.NumFeaAnalyser" -> "qlib.contrib.report.data.base.FeaAnalyser" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.data.ana.RawFeaAna" -> "qlib.contrib.report.data.base.FeaAnalyser" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.data.ana.ValueCNT" -> "qlib.contrib.report.data.base.FeaAnalyser" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.graph.BarGraph" -> "qlib.contrib.report.graph.BaseGraph" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.graph.DistplotGraph" -> "qlib.contrib.report.graph.BaseGraph" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.graph.HeatmapGraph" -> "qlib.contrib.report.graph.BaseGraph" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.graph.HistogramGraph" -> "qlib.contrib.report.graph.BaseGraph" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.report.graph.ScatterGraph" -> "qlib.contrib.report.graph.BaseGraph" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.cost_control.SoftTopkStrategy" -> "qlib.contrib.strategy.signal_strategy.WeightStrategyBase" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.optimizer.enhanced_indexing.EnhancedIndexingOptimizer" -> "qlib.contrib.strategy.optimizer.base.BaseOptimizer" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.optimizer.optimizer.PortfolioOptimizer" -> "qlib.contrib.strategy.optimizer.base.BaseOptimizer" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.order_generator.OrderGenWInteract" -> "qlib.contrib.strategy.order_generator.OrderGenerator" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.order_generator.OrderGenWOInteract" -> "qlib.contrib.strategy.order_generator.OrderGenerator" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.rule_strategy.ACStrategy" -> "qlib.strategy.base.BaseStrategy" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.rule_strategy.FileOrderStrategy" -> "qlib.strategy.base.BaseStrategy" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.rule_strategy.RandomOrderStrategy" -> "qlib.strategy.base.BaseStrategy" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.rule_strategy.SBBStrategyBase" -> "qlib.strategy.base.BaseStrategy" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.rule_strategy.SBBStrategyEMA" -> "qlib.contrib.strategy.rule_strategy.SBBStrategyBase" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.rule_strategy.TWAPStrategy" -> "qlib.strategy.base.BaseStrategy" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.signal_strategy.BaseSignalStrategy" -> "qlib.strategy.base.BaseStrategy" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.signal_strategy.EnhancedIndexingStrategy" -> "qlib.contrib.strategy.signal_strategy.WeightStrategyBase" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.signal_strategy.TopkDropoutStrategy" -> "qlib.contrib.strategy.signal_strategy.BaseSignalStrategy" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.strategy.signal_strategy.WeightStrategyBase" -> "qlib.contrib.strategy.signal_strategy.BaseSignalStrategy" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.tuner.tuner.QLibTuner" -> "qlib.contrib.tuner.tuner.Tuner" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.workflow.record_temp.MultiSegRecord" -> "qlib.workflow.record_temp.RecordTemp" [arrowhead="empty", arrowtail="none"];
"qlib.contrib.workflow.record_temp.SignalMseRecord" -> "qlib.workflow.record_temp.RecordTemp" [arrowhead="empty", arrowtail="none"];
"qlib.data.base.ExpressionOps" -> "qlib.data.base.Expression" [arrowhead="empty", arrowtail="none"];
"qlib.data.base.Feature" -> "qlib.data.base.Expression" [arrowhead="empty", arrowtail="none"];
"qlib.data.cache.CalendarCache" -> "qlib.data.cache.BaseProviderCache" [arrowhead="empty", arrowtail="none"];
"qlib.data.cache.DatasetCache" -> "qlib.data.cache.BaseProviderCache" [arrowhead="empty", arrowtail="none"];
"qlib.data.cache.DatasetURICache" -> "qlib.data.cache.DatasetCache" [arrowhead="empty", arrowtail="none"];
"qlib.data.cache.DiskDatasetCache" -> "qlib.data.cache.DatasetCache" [arrowhead="empty", arrowtail="none"];
"qlib.data.cache.DiskExpressionCache" -> "qlib.data.cache.ExpressionCache" [arrowhead="empty", arrowtail="none"];
"qlib.data.cache.ExpressionCache" -> "qlib.data.cache.BaseProviderCache" [arrowhead="empty", arrowtail="none"];
"qlib.data.cache.MemCacheLengthUnit" -> "qlib.data.cache.MemCacheUnit" [arrowhead="empty", arrowtail="none"];
"qlib.data.cache.MemCacheSizeofUnit" -> "qlib.data.cache.MemCacheUnit" [arrowhead="empty", arrowtail="none"];
"qlib.data.cache.MemoryCalendarCache" -> "qlib.data.cache.CalendarCache" [arrowhead="empty", arrowtail="none"];
"qlib.data.cache.SimpleDatasetCache" -> "qlib.data.cache.DatasetCache" [arrowhead="empty", arrowtail="none"];
"qlib.data.data.ClientCalendarProvider" -> "qlib.data.data.CalendarProvider" [arrowhead="empty", arrowtail="none"];
"qlib.data.data.ClientDatasetProvider" -> "qlib.data.data.DatasetProvider" [arrowhead="empty", arrowtail="none"];
"qlib.data.data.ClientInstrumentProvider" -> "qlib.data.data.InstrumentProvider" [arrowhead="empty", arrowtail="none"];
"qlib.data.data.ClientProvider" -> "qlib.data.data.BaseProvider" [arrowhead="empty", arrowtail="none"];
"qlib.data.data.LocalCalendarProvider" -> "qlib.data.data.CalendarProvider" [arrowhead="empty", arrowtail="none"];
"qlib.data.data.LocalCalendarProvider" -> "qlib.data.data.ProviderBackendMixin" [arrowhead="empty", arrowtail="none"];
"qlib.data.data.LocalDatasetProvider" -> "qlib.data.data.DatasetProvider" [arrowhead="empty", arrowtail="none"];
"qlib.data.data.LocalExpressionProvider" -> "qlib.data.data.ExpressionProvider" [arrowhead="empty", arrowtail="none"];
"qlib.data.data.LocalFeatureProvider" -> "qlib.data.data.FeatureProvider" [arrowhead="empty", arrowtail="none"];
"qlib.data.data.LocalFeatureProvider" -> "qlib.data.data.ProviderBackendMixin" [arrowhead="empty", arrowtail="none"];
"qlib.data.data.LocalInstrumentProvider" -> "qlib.data.data.InstrumentProvider" [arrowhead="empty", arrowtail="none"];
"qlib.data.data.LocalInstrumentProvider" -> "qlib.data.data.ProviderBackendMixin" [arrowhead="empty", arrowtail="none"];
"qlib.data.data.LocalProvider" -> "qlib.data.data.BaseProvider" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.Dataset" -> "qlib.utils.serial.Serializable" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.DatasetH" -> "qlib.data.dataset.Dataset" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.TSDatasetH" -> "qlib.data.dataset.DatasetH" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.handler.DataHandler" -> "qlib.utils.serial.Serializable" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.handler.DataHandlerLP" -> "qlib.data.dataset.handler.DataHandler" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.loader.DLWParser" -> "qlib.data.dataset.loader.DataLoader" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.loader.DataLoaderDH" -> "qlib.data.dataset.loader.DataLoader" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.loader.QlibDataLoader" -> "qlib.data.dataset.loader.DLWParser" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.loader.StaticDataLoader" -> "qlib.data.dataset.loader.DataLoader" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.loader.StaticDataLoader" -> "qlib.utils.serial.Serializable" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.CSRankNorm" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.CSZFillna" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.CSZScoreNorm" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.DropCol" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.DropnaLabel" -> "qlib.data.dataset.processor.DropnaProcessor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.DropnaProcessor" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.Fillna" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.FilterCol" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.HashStockFormat" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.MinMaxNorm" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.ProcessInf" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.Processor" -> "qlib.utils.serial.Serializable" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.RobustZScoreNorm" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.TanhProcess" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.processor.ZScoreNorm" -> "qlib.data.dataset.processor.Processor" [arrowhead="empty", arrowtail="none"];
"qlib.data.dataset.storage.HasingStockStorage" -> "qlib.data.dataset.storage.BaseHandlerStorage" [arrowhead="empty", arrowtail="none"];
"qlib.data.filter.ExpressionDFilter" -> "qlib.data.filter.SeriesDFilter" [arrowhead="empty", arrowtail="none"];
"qlib.data.filter.NameDFilter" -> "qlib.data.filter.SeriesDFilter" [arrowhead="empty", arrowtail="none"];
"qlib.data.filter.SeriesDFilter" -> "qlib.data.filter.BaseDFilter" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Abs" -> "qlib.data.ops.NpElemOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Add" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.And" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Corr" -> "qlib.data.ops.PairRolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Count" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Cov" -> "qlib.data.ops.PairRolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Delta" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Div" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.EMA" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.ElemOperator" -> "qlib.data.base.ExpressionOps" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Eq" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Ge" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Greater" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Gt" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.IdxMax" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.IdxMin" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.If" -> "qlib.data.base.ExpressionOps" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Kurt" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Le" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Less" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Log" -> "qlib.data.ops.NpElemOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Lt" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Mad" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Mask" -> "qlib.data.ops.NpElemOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Max" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Mean" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Med" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Min" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Mul" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Ne" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Not" -> "qlib.data.ops.NpElemOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.NpElemOperator" -> "qlib.data.ops.ElemOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.NpPairOperator" -> "qlib.data.ops.PairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Or" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.PairOperator" -> "qlib.data.base.ExpressionOps" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.PairRolling" -> "qlib.data.base.ExpressionOps" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Power" -> "qlib.data.ops.NpElemOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Quantile" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Rank" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Ref" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Resi" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Rolling" -> "qlib.data.base.ExpressionOps" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Rsquare" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Sign" -> "qlib.data.ops.NpElemOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Skew" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Slope" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Std" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Sub" -> "qlib.data.ops.NpPairOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Sum" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.TResample" -> "qlib.data.ops.ElemOperator" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.Var" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.ops.WMA" -> "qlib.data.ops.Rolling" [arrowhead="empty", arrowtail="none"];
"qlib.data.storage.file_storage.FileCalendarStorage" -> "qlib.data.storage.file_storage.FileStorageMixin" [arrowhead="empty", arrowtail="none"];
"qlib.data.storage.file_storage.FileCalendarStorage" -> "qlib.data.storage.storage.CalendarStorage" [arrowhead="empty", arrowtail="none"];
"qlib.data.storage.file_storage.FileFeatureStorage" -> "qlib.data.storage.file_storage.FileStorageMixin" [arrowhead="empty", arrowtail="none"];
"qlib.data.storage.file_storage.FileFeatureStorage" -> "qlib.data.storage.storage.FeatureStorage" [arrowhead="empty", arrowtail="none"];
"qlib.data.storage.file_storage.FileInstrumentStorage" -> "qlib.data.storage.file_storage.FileStorageMixin" [arrowhead="empty", arrowtail="none"];
"qlib.data.storage.file_storage.FileInstrumentStorage" -> "qlib.data.storage.storage.InstrumentStorage" [arrowhead="empty", arrowtail="none"];
"qlib.data.storage.storage.CalendarStorage" -> "qlib.data.storage.storage.BaseStorage" [arrowhead="empty", arrowtail="none"];
"qlib.data.storage.storage.FeatureStorage" -> "qlib.data.storage.storage.BaseStorage" [arrowhead="empty", arrowtail="none"];
"qlib.data.storage.storage.InstrumentStorage" -> "qlib.data.storage.storage.BaseStorage" [arrowhead="empty", arrowtail="none"];
"qlib.model.base.BaseModel" -> "qlib.utils.serial.Serializable" [arrowhead="empty", arrowtail="none"];
"qlib.model.base.Model" -> "qlib.model.base.BaseModel" [arrowhead="empty", arrowtail="none"];
"qlib.model.base.ModelFT" -> "qlib.model.base.Model" [arrowhead="empty", arrowtail="none"];
"qlib.model.ens.ensemble.AverageEnsemble" -> "qlib.model.ens.ensemble.Ensemble" [arrowhead="empty", arrowtail="none"];
"qlib.model.ens.ensemble.RollingEnsemble" -> "qlib.model.ens.ensemble.Ensemble" [arrowhead="empty", arrowtail="none"];
"qlib.model.ens.ensemble.SingleKeyEnsemble" -> "qlib.model.ens.ensemble.Ensemble" [arrowhead="empty", arrowtail="none"];
"qlib.model.ens.group.RollingGroup" -> "qlib.model.ens.group.Group" [arrowhead="empty", arrowtail="none"];
"qlib.model.interpret.base.LightGBMFInt" -> "qlib.model.interpret.base.FeatureInt" [arrowhead="empty", arrowtail="none"];
"qlib.model.meta.dataset.MetaTaskDataset" -> "qlib.utils.serial.Serializable" [arrowhead="empty", arrowtail="none"];
"qlib.model.meta.model.MetaGuideModel" -> "qlib.model.meta.model.MetaModel" [arrowhead="empty", arrowtail="none"];
"qlib.model.meta.model.MetaTaskModel" -> "qlib.model.meta.model.MetaModel" [arrowhead="empty", arrowtail="none"];
"qlib.model.riskmodel.base.RiskModel" -> "qlib.model.base.BaseModel" [arrowhead="empty", arrowtail="none"];
"qlib.model.riskmodel.poet.POETCovEstimator" -> "qlib.model.riskmodel.base.RiskModel" [arrowhead="empty", arrowtail="none"];
"qlib.model.riskmodel.shrink.ShrinkCovEstimator" -> "qlib.model.riskmodel.base.RiskModel" [arrowhead="empty", arrowtail="none"];
"qlib.model.riskmodel.structured.StructuredCovEstimator" -> "qlib.model.riskmodel.base.RiskModel" [arrowhead="empty", arrowtail="none"];
"qlib.model.trainer.DelayTrainerR" -> "qlib.model.trainer.TrainerR" [arrowhead="empty", arrowtail="none"];
"qlib.model.trainer.DelayTrainerRM" -> "qlib.model.trainer.TrainerRM" [arrowhead="empty", arrowtail="none"];
"qlib.model.trainer.TrainerR" -> "qlib.model.trainer.Trainer" [arrowhead="empty", arrowtail="none"];
"qlib.model.trainer.TrainerRM" -> "qlib.model.trainer.Trainer" [arrowhead="empty", arrowtail="none"];
"qlib.rl.env.QlibIntRLEnv" -> "qlib.rl.env.QlibRLEnv" [arrowhead="empty", arrowtail="none"];
"qlib.rl.interpreter.ActionInterpreter" -> "qlib.rl.interpreter.BaseInterpreter" [arrowhead="empty", arrowtail="none"];
"qlib.rl.interpreter.StateInterpreter" -> "qlib.rl.interpreter.BaseInterpreter" [arrowhead="empty", arrowtail="none"];
"qlib.strategy.base.RLIntStrategy" -> "qlib.strategy.base.RLStrategy" [arrowhead="empty", arrowtail="none"];
"qlib.strategy.base.RLStrategy" -> "qlib.strategy.base.BaseStrategy" [arrowhead="empty", arrowtail="none"];
"qlib.tests.TestOperatorData" -> "qlib.tests.TestAutoData" [arrowhead="empty", arrowtail="none"];
"qlib.utils.exceptions.LoadObjectError" -> "qlib.utils.exceptions.QlibException" [arrowhead="empty", arrowtail="none"];
"qlib.utils.exceptions.RecorderInitializationError" -> "qlib.utils.exceptions.QlibException" [arrowhead="empty", arrowtail="none"];
"qlib.utils.index_data.MultiData" -> "qlib.utils.index_data.IndexData" [arrowhead="empty", arrowtail="none"];
"qlib.utils.index_data.SingleData" -> "qlib.utils.index_data.IndexData" [arrowhead="empty", arrowtail="none"];
"qlib.utils.objm.FileManager" -> "qlib.utils.objm.ObjManager" [arrowhead="empty", arrowtail="none"];
"qlib.utils.paral.DelayedDict" -> "qlib.utils.paral.DelayedTask" [arrowhead="empty", arrowtail="none"];
"qlib.utils.paral.DelayedTuple" -> "qlib.utils.paral.DelayedTask" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.exp.MLflowExperiment" -> "qlib.workflow.exp.Experiment" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.expm.MLflowExpManager" -> "qlib.workflow.expm.ExpManager" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.online.manager.OnlineManager" -> "qlib.utils.serial.Serializable" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.online.strategy.RollingStrategy" -> "qlib.workflow.online.strategy.OnlineStrategy" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.online.update.DSBasedUpdater" -> "qlib.workflow.online.update.RecordUpdater" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.online.update.LabelUpdater" -> "qlib.workflow.online.update.DSBasedUpdater" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.online.update.PredUpdater" -> "qlib.workflow.online.update.DSBasedUpdater" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.online.utils.OnlineToolR" -> "qlib.workflow.online.utils.OnlineTool" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.record_temp.ACRecordTemp" -> "qlib.workflow.record_temp.RecordTemp" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.record_temp.HFSignalRecord" -> "qlib.workflow.record_temp.SignalRecord" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.record_temp.PortAnaRecord" -> "qlib.workflow.record_temp.ACRecordTemp" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.record_temp.SigAnaRecord" -> "qlib.workflow.record_temp.ACRecordTemp" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.record_temp.SignalRecord" -> "qlib.workflow.record_temp.RecordTemp" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.recorder.MLflowRecorder" -> "qlib.workflow.recorder.Recorder" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.task.collect.Collector" -> "qlib.utils.serial.Serializable" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.task.collect.MergeCollector" -> "qlib.workflow.task.collect.Collector" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.task.collect.RecorderCollector" -> "qlib.workflow.task.collect.Collector" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.task.gen.MultiHorizonGenBase" -> "qlib.workflow.task.gen.TaskGen" [arrowhead="empty", arrowtail="none"];
"qlib.workflow.task.gen.RollingGen" -> "qlib.workflow.task.gen.TaskGen" [arrowhead="empty", arrowtail="none"];
"qlib.backtest.account.Account" -> "qlib.backtest.executor.BaseExecutor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="trade_account", style="solid"];
"qlib.backtest.account.AccumulatedInfo" -> "qlib.backtest.account.Account" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="accum_info", style="solid"];
"qlib.backtest.decision.OrderHelper" -> "qlib.backtest.exchange.Exchange" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_order_helper", style="solid"];
"qlib.backtest.exchange.Exchange" -> "qlib.backtest.decision.OrderHelper" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exchange", style="solid"];
"qlib.backtest.executor.BaseExecutor" -> "qlib.backtest.executor.NestedExecutor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="inner_executor", style="solid"];
"qlib.backtest.executor.BaseExecutor" -> "qlib.rl.env.QlibRLEnv" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="executor", style="solid"];
"qlib.backtest.high_performance_ds.BaseOrderIndicator" -> "qlib.backtest.report.Indicator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="order_indicator", style="solid"];
"qlib.backtest.high_performance_ds.BaseQuote" -> "qlib.backtest.exchange.Exchange" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quote", style="solid"];
"qlib.backtest.high_performance_ds.NumpyOrderIndicator" -> "qlib.backtest.report.Indicator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="order_indicator_cls", style="solid"];
"qlib.backtest.high_performance_ds.NumpyQuote" -> "qlib.backtest.exchange.Exchange" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quote_cls", style="solid"];
"qlib.backtest.position.BasePosition" -> "qlib.backtest.account.Account" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="current_position", style="solid"];
"qlib.backtest.report.Indicator" -> "qlib.backtest.account.Account" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="indicator", style="solid"];
"qlib.backtest.report.PortfolioMetrics" -> "qlib.backtest.account.Account" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="portfolio_metrics", style="solid"];
"qlib.backtest.utils.CommonInfrastructure" -> "qlib.strategy.base.BaseStrategy" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="common_infra", style="solid"];
"qlib.backtest.utils.LevelInfrastructure" -> "qlib.backtest.executor.BaseExecutor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="level_infra", style="solid"];
"qlib.contrib.data.utils.sepdf.SepDataFrame" -> "qlib.contrib.data.utils.sepdf.SDFLoc" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_sdf", style="solid"];
"qlib.contrib.meta.data_selection.dataset.InternalData" -> "qlib.contrib.meta.data_selection.dataset.MetaDatasetDS" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="internal_data", style="solid"];
"qlib.contrib.meta.data_selection.net.PredNet" -> "qlib.contrib.meta.data_selection.model.MetaModelDS" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tn", style="solid"];
"qlib.contrib.meta.data_selection.net.TimeWeightMeta" -> "qlib.contrib.meta.data_selection.net.PredNet" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="twm", style="solid"];
"qlib.contrib.model.pytorch_adarnn.AdaRNN" -> "qlib.contrib.model.pytorch_adarnn.ADARNN" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"qlib.contrib.model.pytorch_adarnn.Mine" -> "qlib.contrib.model.pytorch_adarnn.Mine_estimator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="mine_model", style="solid"];
"qlib.contrib.model.pytorch_add.ADDModel" -> "qlib.contrib.model.pytorch_add.ADD" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ADD_model", style="solid"];
"qlib.contrib.model.pytorch_add.Decoder" -> "qlib.contrib.model.pytorch_add.ADDModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dec", style="solid"];
"qlib.contrib.model.pytorch_alstm.ALSTMModel" -> "qlib.contrib.model.pytorch_alstm.ALSTM" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ALSTM_model", style="solid"];
"qlib.contrib.model.pytorch_alstm_ts.ALSTMModel" -> "qlib.contrib.model.pytorch_alstm_ts.ALSTM" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ALSTM_model", style="solid"];
"qlib.contrib.model.pytorch_gats.GATModel" -> "qlib.contrib.model.pytorch_gats.GATs" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="GAT_model", style="solid"];
"qlib.contrib.model.pytorch_gats_ts.GATModel" -> "qlib.contrib.model.pytorch_gats_ts.GATs" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="GAT_model", style="solid"];
"qlib.contrib.model.pytorch_gru.GRUModel" -> "qlib.contrib.model.pytorch_gru.GRU" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="gru_model", style="solid"];
"qlib.contrib.model.pytorch_gru_ts.GRUModel" -> "qlib.contrib.model.pytorch_gru_ts.GRU" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="GRU_model", style="solid"];
"qlib.contrib.model.pytorch_localformer.LocalformerEncoder" -> "qlib.contrib.model.pytorch_localformer.Transformer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transformer_encoder", style="solid"];
"qlib.contrib.model.pytorch_localformer.PositionalEncoding" -> "qlib.contrib.model.pytorch_localformer.Transformer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pos_encoder", style="solid"];
"qlib.contrib.model.pytorch_localformer.Transformer" -> "qlib.contrib.model.pytorch_localformer.LocalformerModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"qlib.contrib.model.pytorch_localformer_ts.LocalformerEncoder" -> "qlib.contrib.model.pytorch_localformer_ts.Transformer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="transformer_encoder", style="solid"];
"qlib.contrib.model.pytorch_localformer_ts.PositionalEncoding" -> "qlib.contrib.model.pytorch_localformer_ts.Transformer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pos_encoder", style="solid"];
"qlib.contrib.model.pytorch_localformer_ts.Transformer" -> "qlib.contrib.model.pytorch_localformer_ts.LocalformerModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"qlib.contrib.model.pytorch_lstm.LSTMModel" -> "qlib.contrib.model.pytorch_lstm.LSTM" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="lstm_model", style="solid"];
"qlib.contrib.model.pytorch_sfm.SFM_Model" -> "qlib.contrib.model.pytorch_sfm.SFM" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="sfm_model", style="solid"];
"qlib.contrib.model.pytorch_tabnet.AttentionTransformer" -> "qlib.contrib.model.pytorch_tabnet.DecisionStep" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="atten_tran", style="solid"];
"qlib.contrib.model.pytorch_tabnet.FeatureTransformer" -> "qlib.contrib.model.pytorch_tabnet.DecisionStep" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fea_tran", style="solid"];
"qlib.contrib.model.pytorch_tabnet.FeatureTransformer" -> "qlib.contrib.model.pytorch_tabnet.DecoderStep" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fea_tran", style="solid"];
"qlib.contrib.model.pytorch_tabnet.FeatureTransformer" -> "qlib.contrib.model.pytorch_tabnet.TabNet" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="first_step", style="solid"];
"qlib.contrib.model.pytorch_tabnet.GBN" -> "qlib.contrib.model.pytorch_tabnet.AttentionTransformer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="bn", style="solid"];
"qlib.contrib.model.pytorch_tabnet.GBN" -> "qlib.contrib.model.pytorch_tabnet.GLU" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="bn", style="solid"];
"qlib.contrib.model.pytorch_tcn.TCNModel" -> "qlib.contrib.model.pytorch_tcn.TCN" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tcn_model", style="solid"];
"qlib.contrib.model.pytorch_tcn_ts.TCNModel" -> "qlib.contrib.model.pytorch_tcn_ts.TCN" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="TCN_model", style="solid"];
"qlib.contrib.model.pytorch_tcts.GRUModel" -> "qlib.contrib.model.pytorch_tcts.TCTS" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fore_model", style="solid"];
"qlib.contrib.model.pytorch_tcts.MLPModel" -> "qlib.contrib.model.pytorch_tcts.TCTS" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="weight_model", style="solid"];
"qlib.contrib.model.pytorch_tra.PositionalEncoding" -> "qlib.contrib.model.pytorch_tra.Transformer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pe", style="solid"];
"qlib.contrib.model.pytorch_transformer.PositionalEncoding" -> "qlib.contrib.model.pytorch_transformer.Transformer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pos_encoder", style="solid"];
"qlib.contrib.model.pytorch_transformer.Transformer" -> "qlib.contrib.model.pytorch_transformer.TransformerModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"qlib.contrib.model.pytorch_transformer_ts.PositionalEncoding" -> "qlib.contrib.model.pytorch_transformer_ts.Transformer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pos_encoder", style="solid"];
"qlib.contrib.model.pytorch_transformer_ts.Transformer" -> "qlib.contrib.model.pytorch_transformer_ts.TransformerModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"qlib.contrib.model.tcn.Chomp1d" -> "qlib.contrib.model.tcn.TemporalBlock" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="chomp1", style="solid"];
"qlib.contrib.model.tcn.Chomp1d" -> "qlib.contrib.model.tcn.TemporalBlock" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="chomp2", style="solid"];
"qlib.contrib.model.tcn.TemporalConvNet" -> "qlib.contrib.model.pytorch_tcn.TCNModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tcn", style="solid"];
"qlib.contrib.model.tcn.TemporalConvNet" -> "qlib.contrib.model.pytorch_tcn_ts.TCNModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tcn", style="solid"];
"qlib.contrib.strategy.optimizer.enhanced_indexing.EnhancedIndexingOptimizer" -> "qlib.contrib.strategy.signal_strategy.EnhancedIndexingStrategy" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="optimizer", style="solid"];
"qlib.contrib.strategy.order_generator.OrderGenWOInteract" -> "qlib.contrib.strategy.signal_strategy.WeightStrategyBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="order_generator", style="solid"];
"qlib.contrib.strategy.order_generator.OrderGenWOInteract" -> "qlib.contrib.strategy.signal_strategy.WeightStrategyBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="order_generator", style="solid"];
"qlib.contrib.tuner.config.OptimizationConfig" -> "qlib.contrib.tuner.config.TunerConfigManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="optim_config", style="solid"];
"qlib.contrib.tuner.config.PipelineExperimentConfig" -> "qlib.contrib.tuner.config.TunerConfigManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pipeline_ex_config", style="solid"];
"qlib.data.cache.MemCacheLengthUnit" -> "qlib.data.cache.MemCache" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="__calendar_mem_cache", style="solid"];
"qlib.data.cache.MemCacheLengthUnit" -> "qlib.data.cache.MemCache" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="__instrument_mem_cache", style="solid"];
"qlib.data.cache.MemCacheLengthUnit" -> "qlib.data.cache.MemCache" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="__feature_mem_cache", style="solid"];
"qlib.data.cache.MemCacheSizeofUnit" -> "qlib.data.cache.MemCache" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="__calendar_mem_cache", style="solid"];
"qlib.data.cache.MemCacheSizeofUnit" -> "qlib.data.cache.MemCache" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="__instrument_mem_cache", style="solid"];
"qlib.data.cache.MemCacheSizeofUnit" -> "qlib.data.cache.MemCache" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="__feature_mem_cache", style="solid"];
"qlib.data.client.Client" -> "qlib.data.data.ClientProvider" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="client", style="solid"];
"qlib.data.dataset.handler.DataHandler" -> "qlib.data.dataset.DatasetH" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="handler", style="solid"];
"qlib.log.QlibLogger" -> "qlib.backtest.exchange.Exchange" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.backtest.high_performance_ds.BaseOrderIndicator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.backtest.high_performance_ds.BaseQuote" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.double_ensemble.DEnsembleModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_adarnn.ADARNN" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_add.ADD" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_alstm.ALSTM" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_alstm_ts.ALSTM" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_gats.GATs" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_gats_ts.GATs" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_gru.GRU" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_gru_ts.GRU" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_localformer.LocalformerModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_localformer_ts.LocalformerModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_lstm.LSTM" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_lstm_ts.LSTM" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_nn.DNNModelPytorch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_sfm.SFM" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_tabnet.TabnetModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_tcn.TCN" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_tcn_ts.TCN" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_tcts.TCTS" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_tra.TRAModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_transformer.TransformerModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.model.pytorch_transformer_ts.TransformerModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.online.operator.Operator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.online.user.User" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.strategy.signal_strategy.EnhancedIndexingStrategy" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.tuner.pipeline.Pipeline" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.contrib.tuner.tuner.Tuner" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.data.cache.BaseProviderCache" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.data.cache.DiskDatasetCache.IndexManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.data.client.Client" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.data.data.ClientProvider" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.log.TimeInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="timer_logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.workflow.online.manager.OnlineManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.workflow.online.strategy.OnlineStrategy" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.workflow.online.update.RecordUpdater" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.workflow.online.utils.OnlineTool" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.log.QlibLogger" -> "qlib.workflow.task.manage.TaskManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"qlib.model.base.BaseModel" -> "qlib.backtest.signal.ModelSignal" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"qlib.strategy.base.BaseStrategy" -> "qlib.backtest.decision.BaseTradeDecision" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="strategy", style="solid"];
"qlib.strategy.base.BaseStrategy" -> "qlib.backtest.executor.NestedExecutor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="inner_strategy", style="solid"];
"qlib.utils.index_data.LocIndexer" -> "qlib.utils.index_data.IndexData" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="loc_idx_cls", style="solid"];
"qlib.utils.paral.AsyncCaller" -> "qlib.workflow.recorder.MLflowRecorder" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="async_log", style="solid"];
"qlib.utils.paral.DelayedTuple" -> "qlib.contrib.report.data.ana.FeaACAna" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_fea_corr", style="solid"];
"qlib.utils.time.Freq" -> "qlib.data.storage.file_storage.FileCalendarStorage" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_freq_file_cache", style="solid"];
"qlib.workflow.expm.ExpManager" -> "qlib.workflow.QlibRecorder" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exp_manager", style="solid"];
"qlib.workflow.online.update.RMDLoader" -> "qlib.workflow.online.update.DSBasedUpdater" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="rmdl", style="solid"];
"qlib.workflow.online.utils.OnlineTool" -> "qlib.workflow.online.strategy.OnlineStrategy" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tool", style="solid"];
"qlib.workflow.online.utils.OnlineToolR" -> "qlib.workflow.online.strategy.RollingStrategy" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tool", style="solid"];
"qlib.workflow.record_temp.SignalRecord" -> "qlib.contrib.workflow.record_temp.SignalMseRecord" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="depend_cls", style="solid"];
"qlib.workflow.record_temp.SignalRecord" -> "qlib.workflow.record_temp.HFSignalRecord" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="depend_cls", style="solid"];
"qlib.workflow.record_temp.SignalRecord" -> "qlib.workflow.record_temp.PortAnaRecord" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="depend_cls", style="solid"];
"qlib.workflow.record_temp.SignalRecord" -> "qlib.workflow.record_temp.SigAnaRecord" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="depend_cls", style="solid"];
"qlib.workflow.recorder.MLflowRecorder" -> "qlib.workflow.exp.MLflowExperiment" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="active_recorder", style="solid"];
"qlib.workflow.recorder.Recorder" -> "qlib.workflow.online.update.RMDLoader" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="rec", style="solid"];
"qlib.workflow.recorder.Recorder" -> "qlib.workflow.online.update.RecordUpdater" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="record", style="solid"];
"qlib.workflow.task.gen.RollingGen" -> "qlib.workflow.online.strategy.RollingStrategy" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="rg", style="solid"];
"qlib.workflow.task.utils.TimeAdjuster" -> "qlib.contrib.meta.data_selection.dataset.MetaDatasetDS" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ta", style="solid"];
"qlib.workflow.task.utils.TimeAdjuster" -> "qlib.workflow.online.strategy.RollingStrategy" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ta", style="solid"];
"qlib.workflow.task.utils.TimeAdjuster" -> "qlib.workflow.task.gen.MultiHorizonGenBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ta", style="solid"];
"qlib.workflow.task.utils.TimeAdjuster" -> "qlib.workflow.task.gen.RollingGen" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ta", style="solid"];
}
